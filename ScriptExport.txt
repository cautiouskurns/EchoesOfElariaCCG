// File: ScriptExporter.cs
//===========================================
using UnityEngine;
using UnityEditor;
using System.IO;
using System.Text;

public class ScriptExporter : EditorWindow
{
    [MenuItem("Tools/Export Scripts to Text File")]
    public static void ExportScripts()
    {
        string projectPath = Application.dataPath;
        string outputPath = Path.Combine(Application.dataPath, "../ScriptExport.txt");
        StringBuilder content = new StringBuilder();

        // Find all .cs files in the Assets folder and its subfolders
        string[] scriptFiles = Directory.GetFiles(projectPath, "*.cs", SearchOption.AllDirectories);

        foreach (string filePath in scriptFiles)
        {
            content.AppendLine($"// File: {Path.GetFileName(filePath)}");
            content.AppendLine("//===========================================");
            content.AppendLine(File.ReadAllText(filePath));
            content.AppendLine("\n\n");
        }

        // Write to file
        File.WriteAllText(outputPath, content.ToString());
        Debug.Log($"Scripts exported to: {outputPath}");
        
        // Open the folder containing the exported file
        EditorUtility.RevealInFinder(outputPath);
    }
}




// File: EnemyAIManager.cs
//===========================================
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class EnemyAIManager : MonoBehaviour
{
    public static EnemyAIManager Instance { get; private set; }

    [SerializeField] private List<CardData> enemyActions;
    [SerializeField] private float actionDelay = 1.5f;

    private void Awake()
    {
        if (Instance == null) Instance = this;
        else Destroy(gameObject);
    }

    public void ExecuteEnemyTurn()
    {
        StartCoroutine(ProcessEnemyTurn());
    }

    private IEnumerator ProcessEnemyTurn()
    {
        Debug.Log("[EnemyAI] ü§ñ Processing enemy turn");

        // Get all active enemy and player units
        var enemies = FindObjectsByType<EnemyUnit>(FindObjectsSortMode.None);
        var players = FindObjectsByType<PlayerUnit>(FindObjectsSortMode.None);

        foreach (var enemy in enemies)
        {
            enemy.Stats.RefreshActionPoints();

            while (enemy.Stats.CurrentActionPoints > 0)
            {
                // Select an action and a target
                var action = SelectRandomAction(enemy);
                var target = SelectRandomTarget(players);

                if (action == null || target == null)
                {
                    Debug.LogWarning("[EnemyAI] ‚ö†Ô∏è No valid action or target found!");
                    break;
                }

                if (action.Cost > enemy.Stats.CurrentActionPoints)
                {
                    Debug.Log($"[EnemyAI] ‚ùå {enemy.Name} does not have enough AP for {action.CardName}");
                    break; // Not enough AP for action
                }

                yield return StartCoroutine(PerformEnemyAttack(enemy, target, action));

                // Spend AP after the attack sequence
                enemy.Stats.UseActionPoints(action.Cost);

                yield return new WaitForSeconds(actionDelay);
            }
        }

        Debug.Log("[EnemyAI] ‚úÖ Enemy turn complete");
        TurnManager.Instance.EndEnemyTurn();
    }

    /// <summary>
    /// ‚úÖ Selects a random action from the enemy's available actions.
    /// </summary>
    private CardData SelectRandomAction(EnemyUnit enemy)
    {
        if (enemyActions.Count == 0) return null;
        return enemyActions[Random.Range(0, enemyActions.Count)];
    }

    /// <summary>
    /// ‚úÖ Selects a random player target.
    /// </summary>
    private PlayerUnit SelectRandomTarget(PlayerUnit[] players)
    {
        if (players.Length == 0) return null;
        return players[Random.Range(0, players.Length)];
    }

    /// <summary>
    /// ‚úÖ Moves the enemy, plays attack animation, and applies effect.
    /// </summary>
    private IEnumerator PerformEnemyAttack(EnemyUnit enemy, PlayerUnit target, CardData action)
    {
        Debug.Log($"[EnemyAI] üéØ {enemy.Name} is attacking {target.Name} with {action.CardName}");

        // Show intent
        enemy.ShowIntent(action);
        yield return new WaitForSeconds(1f);

        // Perform attack
        EnemyAnimationController animationController = enemy.GetComponentInChildren<EnemyAnimationController>();
        if (animationController == null)
        {
            Debug.LogError($"[EnemyAI] ‚ùå No EnemyAnimationController found on {enemy.Name}");
            yield break;
        }

        Vector3 targetPosition = target.transform.position;

        // ‚úÖ Move toward the player (Dash)
        yield return StartCoroutine(animationController.PlayAttackSequence(targetPosition));

        // ‚úÖ Calculate final effect value
        float multiplier = enemy.Stats.CharacterClass == action.PreferredClass ? action.ClassBonus : 1f;
        int finalValue = Mathf.RoundToInt(action.EffectValue * multiplier);

        // ‚úÖ Apply the card effect
        action.CardEffect.ApplyEffect(target, finalValue);
        Debug.Log($"[EnemyAI] üî• {target.Name} took {finalValue} damage from {enemy.Name}!");

        // ‚úÖ Return to original position after attack
        yield return StartCoroutine(animationController.MoveToTarget(animationController.OriginalPosition));

        // Hide intent after attack
        enemy.HideIntent();
    }
}




// File: CardSoundConfig.cs
//===========================================
public static class CardSoundConfig
{
    // Sound effect names - must match AudioManager's Sound.name exactly
    public const string ATTACK_SLASH = "AttackSlash";
    public const string FIREBALL = "FireballCast";
    public const string HEAL = "HealEffect";
    public const string CARD_DRAW = "CardDraw";
    public const string CARD_PLAY = "CardPlay";
}




// File: AudioManager.cs
//===========================================
using UnityEngine;
using System.Collections.Generic;

public class AudioManager : MonoBehaviour
{
    public static AudioManager Instance { get; private set; }

    public enum AudioType
    {
        UI,
        CardEffects,
        Combat,
        Music
    }

    [System.Serializable]
    public class Sound
    {
        public string name;
        public AudioType type;
        public AudioClip clip;
        [Range(0f, 1f)]
        public float volume = 1f;
        [Range(0.1f, 3f)]
        public float pitch = 1f;
        public bool loop;
    }

    [Header("Audio Sources")]
    [SerializeField] private AudioSource[] musicSources;  // Array for crossfading
    [SerializeField] private AudioSource[] sfxSources;    // Pool of sources for multiple SFX

    [Header("Audio Settings")]
    [SerializeField] private float musicFadeTime = 1f;
    [SerializeField] private int sfxSourcesCount = 5;

    [Header("Audio Collections")]
    [SerializeField] private Sound[] cardSounds;    // Card-related sounds
    [SerializeField] private Sound[] combatSounds;  // Combat effects
    [SerializeField] private Sound[] uiSounds;      // UI feedback
    [SerializeField] private Sound[] musicTracks;   // Background music

    [Header("Audio Mixer")]
    [SerializeField] private UnityEngine.Audio.AudioMixer audioMixer;
    [SerializeField] private UnityEngine.Audio.AudioMixerGroup musicGroup;
    [SerializeField] private UnityEngine.Audio.AudioMixerGroup sfxGroup;
    [SerializeField] private UnityEngine.Audio.AudioMixerGroup uiGroup;

    private Dictionary<string, Sound> soundDictionary = new Dictionary<string, Sound>();
    private int currentMusicSourceIndex = 0;
    private bool isFading = false;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            transform.parent = null; // Ensure it's a root GameObject
            DontDestroyOnLoad(gameObject);
            InitializeAudioSources();
            InitializeAudioDictionary();
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        Debug.Log("[AudioManager] üéµ Attempting to start music...");
        
        // Check if we have any music tracks
        if (musicTracks != null && musicTracks.Length > 0 && musicTracks[0].clip != null)
        {
            PlayMusic(musicTracks[0].name, fadeIn: false);
            Debug.Log($"[AudioManager] üéµ Playing track: {musicTracks[0].name}");
        }
        else
        {
            Debug.LogError("[AudioManager] ‚ùå No music tracks assigned!");
        }

        // Add test keys for manual testing
        Debug.Log("[AudioManager] Test controls: M = Music, S = SFX");
    }

    private void InitializeAudioSources()
    {
        // Create music sources for crossfading
        musicSources = new AudioSource[2];
        for (int i = 0; i < 2; i++)
        {
            musicSources[i] = gameObject.AddComponent<AudioSource>();
            musicSources[i].playOnAwake = false;
            musicSources[i].outputAudioMixerGroup = musicGroup; // Assign mixer group
        }

        // Create SFX source pool
        sfxSources = new AudioSource[sfxSourcesCount];
        for (int i = 0; i < sfxSourcesCount; i++)
        {
            sfxSources[i] = gameObject.AddComponent<AudioSource>();
            sfxSources[i].playOnAwake = false;
            sfxSources[i].outputAudioMixerGroup = sfxGroup; // Assign mixer group
        }

        // Only set mixer values if they exist
        if (audioMixer != null)
        {
            try
            {
                audioMixer.SetFloat("MasterVolume", 0f);
                audioMixer.SetFloat("BGMVolume", 0f);
                audioMixer.SetFloat("SFXVolume", 0f);
            }
            catch (System.Exception e)
            {
                Debug.LogWarning($"[AudioManager] Failed to set mixer values: {e.Message}");
            }
        }
        else
        {
            Debug.LogError("[AudioManager] Audio Mixer not assigned!");
        }
    }

    private void InitializeAudioDictionary()
    {
        AddSoundsToDictionary(cardSounds);
        AddSoundsToDictionary(combatSounds);
        AddSoundsToDictionary(uiSounds);
        AddSoundsToDictionary(musicTracks);
    }

    private void AddSoundsToDictionary(Sound[] sounds)
    {
        foreach (Sound s in sounds)
        {
            if (!soundDictionary.ContainsKey(s.name))
            {
                soundDictionary.Add(s.name, s);
            }
        }
    }

    public void PlaySound(string soundName)
    {
        if (!soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            Debug.LogWarning($"[AudioManager] ‚ùå Sound '{soundName}' not found in dictionary!");
            return;
        }
        PlaySound(sound.clip);
    }

    public void PlaySound(AudioClip clip)
    {
        if (clip == null)
        {
            Debug.LogWarning("[AudioManager] ‚ùå Sound clip is null! Check the card's assigned sound.");
            return;
        }

        // Find available SFX source
        AudioSource source = GetAvailableSFXSource();
        if (source != null)
        {
            source.clip = clip;
            source.PlayOneShot(clip);
            Debug.Log($"[AudioManager] üîä Playing AudioClip: {clip.name}");
        }
    }
    
    private AudioSource GetAvailableSFXSource()
    {
        foreach (AudioSource source in sfxSources)
        {
            if (!source.isPlaying) return source;
        }
        Debug.LogWarning("[AudioManager] No available audio sources!");
        return null;
    }

    public void PlayMusic(string trackName, bool fadeIn = true)
    {
        if (!soundDictionary.TryGetValue(trackName, out Sound music)) return;

        if (fadeIn && !isFading)
        {
            StartCoroutine(CrossFadeMusic(music));
        }
        else
        {
            AudioSource currentSource = musicSources[currentMusicSourceIndex];
            currentSource.clip = music.clip;
            currentSource.volume = music.volume;
            currentSource.loop = true;
            currentSource.Play();
        }
    }

    private System.Collections.IEnumerator CrossFadeMusic(Sound newMusic)
    {
        isFading = true;
        
        int nextSourceIndex = 1 - currentMusicSourceIndex;
        AudioSource fadeOut = musicSources[currentMusicSourceIndex];
        AudioSource fadeIn = musicSources[nextSourceIndex];

        fadeIn.clip = newMusic.clip;
        fadeIn.loop = true;
        fadeIn.volume = 0;
        fadeIn.Play();

        float timer = 0;
        while (timer < musicFadeTime)
        {
            timer += Time.deltaTime;
            float t = timer / musicFadeTime;
            fadeIn.volume = Mathf.Lerp(0, newMusic.volume, t);
            if (fadeOut.isPlaying)
                fadeOut.volume = Mathf.Lerp(fadeOut.volume, 0, t);
            yield return null;
        }

        fadeOut.Stop();
        currentMusicSourceIndex = nextSourceIndex;
        isFading = false;
    }

    // Add test method (remove after testing)
    private void Update()
    {
        // Test controls
        if (Input.GetKeyDown(KeyCode.M))
        {
            if (musicTracks != null && musicTracks.Length > 0)
            {
                PlayMusic(musicTracks[0].name);
                Debug.Log($"[AudioManager] üéµ Manually playing music: {musicTracks[0].name}");
            }
        }
        
        if (Input.GetKeyDown(KeyCode.S))
        {
            if (cardSounds != null && cardSounds.Length > 0)
            {
                PlaySound(cardSounds[0].name);
                Debug.Log($"[AudioManager] üîä Testing sound: {cardSounds[0].name}");
            }
        }

        if (Input.GetKeyDown(KeyCode.Space))
        {
            PlaySound("CardDraw");
            Debug.Log("Attempted to play CardDraw sound");
        }
    }

    // Add validation method
    private void OnValidate()
    {
        // Ensure we have default sounds
        if (cardSounds == null || cardSounds.Length == 0)
        {
            cardSounds = new Sound[]
            {
                new Sound { name = CardSoundConfig.CARD_DRAW, type = AudioType.CardEffects },
                new Sound { name = CardSoundConfig.CARD_PLAY, type = AudioType.CardEffects },
                new Sound { name = CardSoundConfig.ATTACK_SLASH, type = AudioType.CardEffects },
                new Sound { name = CardSoundConfig.FIREBALL, type = AudioType.CardEffects },
                new Sound { name = CardSoundConfig.HEAL, type = AudioType.CardEffects }
            };
        }
    }
}




// File: EnemyIntentUI.cs
//===========================================
using UnityEngine;
using TMPro;
using UnityEngine.UI;
using DG.Tweening;

public class EnemyIntentUI : MonoBehaviour
{
    [Header("UI References")]
    [SerializeField] private Image cardIcon;
    [SerializeField] private TextMeshProUGUI intentText;
    [SerializeField] private CanvasGroup canvasGroup;

    [Header("Animation")]
    [SerializeField] private float fadeInDuration = 0.3f;
    [SerializeField] private float fadeOutDuration = 0.2f;
    [SerializeField] private float floatHeight = 0.5f;

    private void Awake()
    {
        if (canvasGroup == null) canvasGroup = GetComponent<CanvasGroup>();
        HideInstant();
    }

    public void ShowIntent(CardData card)
    {
        if (card == null) return;

        // Ensure GameObject is active
        gameObject.SetActive(true);

        // Set content
        cardIcon.sprite = card.CardArt;
        intentText.text = $"Will use {card.CardName}";

        // Reset position before animating
        // transform.localPosition = Vector3.zero;

        // Animate
        transform.DOKill();
        canvasGroup.DOKill();

        canvasGroup.alpha = 0;
        canvasGroup.blocksRaycasts = true;

        Sequence showSequence = DOTween.Sequence();
        showSequence.Join(canvasGroup.DOFade(1, fadeInDuration))
                   .Join(transform.DOLocalMoveY(floatHeight, fadeInDuration))
                   .SetEase(Ease.OutQuad);

        Debug.Log($"[EnemyIntentUI] Showing intent for {card.CardName}");
    }

    public void HideIntent()
    {
        transform.DOKill();
        canvasGroup.DOKill();

        Sequence hideSequence = DOTween.Sequence();
        hideSequence.Join(canvasGroup.DOFade(0, fadeOutDuration))
                   .Join(transform.DOLocalMoveY(0, fadeOutDuration))
                   .SetEase(Ease.InQuad)
                   .OnComplete(() => {
                       canvasGroup.blocksRaycasts = false;
                       gameObject.SetActive(false);
                   });
    }

    private void HideInstant()
    {
        canvasGroup.alpha = 0;
        canvasGroup.blocksRaycasts = false;
    }
}




// File: ReadOnlyAttribute.cs
//===========================================

using UnityEngine;

namespace EchoesOfElaria.Editor
{
    public class ReadOnlyAttribute : PropertyAttribute { }
}



// File: ReadOnlyDrawer.cs
//===========================================




// File: SpriteGenerator.cs
//===========================================
using UnityEngine;

[RequireComponent(typeof(SpriteRenderer))]
public class SpriteGenerator : MonoBehaviour
{
    [Header("Sprite Settings")]
    [SerializeField] private int width = 256;      // Width of the sprite
    [SerializeField] private int height = 256;     // Height of the sprite
    [SerializeField] private Color fillColor = Color.green;  // Color to fill the sprite

    [Header("Shape Settings")]
    public ShapeType shape = ShapeType.Square;    // Shape type: Square or Circle

    private SpriteRenderer spriteRenderer;

    public enum ShapeType
    {
        Square,
        Circle
    }

    private void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        GenerateSprite();
    }

    [ContextMenu("Generate Sprite")]
    public void GenerateSprite()
    {
        Texture2D texture = new Texture2D(width, height, TextureFormat.ARGB32, false);
        texture.filterMode = FilterMode.Point;  // Makes edges sharp for pixel art
        texture.wrapMode = TextureWrapMode.Clamp;

        Color[] pixels = new Color[width * height];

        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                int index = x + y * width;

                if (shape == ShapeType.Circle)
                {
                    float centerX = width / 2f;
                    float centerY = height / 2f;
                    float radius = Mathf.Min(width, height) / 2f;

                    float distance = Vector2.Distance(new Vector2(x, y), new Vector2(centerX, centerY));
                    pixels[index] = distance <= radius ? fillColor : Color.clear;
                }
                else // Square
                {
                    pixels[index] = fillColor;
                }
            }
        }

        texture.SetPixels(pixels);
        texture.Apply();

        // Create the sprite
        Sprite sprite = Sprite.Create(texture, new Rect(0, 0, width, height), new Vector2(0.5f, 0.5f), 100f);
        spriteRenderer.sprite = sprite;

        Debug.Log($"[SpriteGenerator] ‚úÖ Sprite generated successfully ({shape}) with color {fillColor}.");
    }
}




// File: Bandit.cs
//===========================================
using UnityEngine;
using System.Collections;

public class Bandit : MonoBehaviour {

    [SerializeField] float      m_speed = 4.0f;
    [SerializeField] float      m_jumpForce = 7.5f;

    private Animator            m_animator;
    private Rigidbody2D         m_body2d;
    private Sensor_Bandit       m_groundSensor;
    private bool                m_grounded = false;
    private bool                m_combatIdle = false;
    private bool                m_isDead = false;

    // Use this for initialization
    void Start () {
        m_animator = GetComponent<Animator>();
        m_body2d = GetComponent<Rigidbody2D>();
        m_groundSensor = transform.Find("GroundSensor").GetComponent<Sensor_Bandit>();
    }
	
	// Update is called once per frame
	void Update () {
        //Check if character just landed on the ground
        if (!m_grounded && m_groundSensor.State()) {
            m_grounded = true;
            m_animator.SetBool("Grounded", m_grounded);
        }

        //Check if character just started falling
        if(m_grounded && !m_groundSensor.State()) {
            m_grounded = false;
            m_animator.SetBool("Grounded", m_grounded);
        }

        // -- Handle input and movement --
        float inputX = Input.GetAxis("Horizontal");

        // Swap direction of sprite depending on walk direction
        if (inputX > 0)
            transform.localScale = new Vector3(-1.0f, 1.0f, 1.0f);
        else if (inputX < 0)
            transform.localScale = new Vector3(1.0f, 1.0f, 1.0f);

        // Move
        m_body2d.linearVelocity = new Vector2(inputX * m_speed, m_body2d.linearVelocity.y);

        //Set AirSpeed in animator
        m_animator.SetFloat("AirSpeed", m_body2d.linearVelocity.y);

        // -- Handle Animations --
        //Death
        if (Input.GetKeyDown("e")) {
            if(!m_isDead)
                m_animator.SetTrigger("Death");
            else
                m_animator.SetTrigger("Recover");

            m_isDead = !m_isDead;
        }
            
        //Hurt
        else if (Input.GetKeyDown("q"))
            m_animator.SetTrigger("Hurt");

        //Attack
        else if(Input.GetMouseButtonDown(0)) {
            m_animator.SetTrigger("Attack");
        }

        //Change between idle and combat idle
        else if (Input.GetKeyDown("f"))
            m_combatIdle = !m_combatIdle;

        //Jump
        else if (Input.GetKeyDown("space") && m_grounded) {
            m_animator.SetTrigger("Jump");
            m_grounded = false;
            m_animator.SetBool("Grounded", m_grounded);
            m_body2d.linearVelocity = new Vector2(m_body2d.linearVelocity.x, m_jumpForce);
            m_groundSensor.Disable(0.2f);
        }

        //Run
        else if (Mathf.Abs(inputX) > Mathf.Epsilon)
            m_animator.SetInteger("AnimState", 2);

        //Combat Idle
        else if (m_combatIdle)
            m_animator.SetInteger("AnimState", 1);

        //Idle
        else
            m_animator.SetInteger("AnimState", 0);
    }
}




// File: Sensor_Bandit.cs
//===========================================
using UnityEngine;
using System.Collections;

public class Sensor_Bandit : MonoBehaviour {

    private int m_ColCount = 0;

    private float m_DisableTimer;

    private void OnEnable()
    {
        m_ColCount = 0;
    }

    public bool State()
    {
        if (m_DisableTimer > 0)
            return false;
        return m_ColCount > 0;
    }

    void OnTriggerEnter2D(Collider2D other)
    {
        m_ColCount++;
    }

    void OnTriggerExit2D(Collider2D other)
    {
        m_ColCount--;
    }

    void Update()
    {
        m_DisableTimer -= Time.deltaTime;
    }

    public void Disable(float duration)
    {
        m_DisableTimer = duration;
    }
}




// File: ColorSwap_HeroKnight.cs
//===========================================
using UnityEngine;
using System.Collections.Generic;
using System;

public class ColorSwap_HeroKnight : MonoBehaviour
{
    // Accessable in Editor
    [SerializeField] Color[] m_sourceColors;
    [SerializeField] Color[] m_newColors;

    // Private member variables
    Texture2D m_colorSwapTex;
    Color[] m_spriteColors; 
    SpriteRenderer m_spriteRenderer;
    bool m_init = false;

    // Initialize values
    void Awake()
    {
        m_spriteRenderer = GetComponent<SpriteRenderer>();
        InitColorSwapTex();
        
        SwapDemoColors();
    }

    // OnValidate is called every time m_sourceColors or m_newColors is changed in editor. 
    // Only possible to change colors in real time when in play mode.
    private void OnValidate()
    {
        if (m_init)
        {
            SwapDemoColors();
        }
    }

    // Uses the value from the red channel in the source color (0-255) as an index for where to place the new color into the swap texture (256x1 px)
    public void SwapDemoColors()
    {
        for(int i = 0; i < m_sourceColors.Length && i < m_newColors.Length; i++)
        {
            SwapColor((int)(m_sourceColors[i].r * 255.0f), m_newColors[i]);
        }
        if(m_colorSwapTex)
            m_colorSwapTex.Apply();
    }

    public static Color ColorFromInt(int c, float alpha = 1.0f)
    {
        int r = (c >> 16) & 0x000000FF;
        int g = (c >> 8) & 0x000000FF;
        int b = c & 0x000000FF;

        Color ret = ColorFromIntRGB(r, g, b);
        ret.a = alpha;

        return ret;
    }

    public static Color ColorFromIntRGB(int r, int g, int b)
    {
        return new Color((float)r / 255.0f, (float)g / 255.0f, (float)b / 255.0f, 1.0f);
    }

    public void InitColorSwapTex()
    {
        Texture2D colorSwapTex = new Texture2D(256, 1, TextureFormat.RGBA32, false, false);
        colorSwapTex.filterMode = FilterMode.Point;

        for (int i = 0; i < colorSwapTex.width; ++i)
            colorSwapTex.SetPixel(i, 0, new Color(0.0f, 0.0f, 0.0f, 0.0f));

        colorSwapTex.Apply();

        m_spriteRenderer.material.SetTexture("_SwapTex", colorSwapTex);

        m_spriteColors = new Color[colorSwapTex.width];
        m_colorSwapTex = colorSwapTex;
        m_init = true;
    }

    public void SwapColor(int index, Color color)
    {
        if(index >= 0 && index < 256)
        {
            m_spriteColors[index] = color;
            m_colorSwapTex.SetPixel(index, 0, color);
        }
    }


    public void SwapColors(List<int> indexes, List<Color> colors)
    {
        for (int i = 0; i < indexes.Count; ++i)
        {
            m_spriteColors[indexes[i]] = colors[i];
            m_colorSwapTex.SetPixel(indexes[i], 0, colors[i]);
        }
        m_colorSwapTex.Apply();
    }

    public void ClearColor(int index)
    {
        Color c = new Color(0.0f, 0.0f, 0.0f, 0.0f);
        m_spriteColors[index] = c;
        m_colorSwapTex.SetPixel(index, 0, c);
    }

    public void SwapAllSpritesColorsTemporarily(Color color)
    {
        for (int i = 0; i < m_colorSwapTex.width; ++i)
            m_colorSwapTex.SetPixel(i, 0, color);
        m_colorSwapTex.Apply();
    }

    public void ResetAllSpritesColors()
    {
        for (int i = 0; i < m_colorSwapTex.width; ++i)
            m_colorSwapTex.SetPixel(i, 0, m_spriteColors[i]);
        m_colorSwapTex.Apply();
    }

    public void ClearAllSpritesColors()
    {
        for (int i = 0; i < m_colorSwapTex.width; ++i)
        {
            m_colorSwapTex.SetPixel(i, 0, new Color(0.0f, 0.0f, 0.0f, 0.0f));
            m_spriteColors[i] = new Color(0.0f, 0.0f, 0.0f, 0.0f);
        }
        m_colorSwapTex.Apply();
    }
}



// File: DestroyEvent_HeroKnight.cs
//===========================================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DestroyEvent_HeroKnight : MonoBehaviour
{
    // Destroy particles when animation has finished playing. 
    // destroyEvent() is called as an event in animations.
    public void destroyEvent()
    {
        Destroy(gameObject);
    }
}




// File: HeroKnight.cs
//===========================================
using UnityEngine;
using System.Collections;

public class HeroKnight : MonoBehaviour {

    [SerializeField] float      m_speed = 4.0f;
    [SerializeField] float      m_jumpForce = 7.5f;
    [SerializeField] float      m_rollForce = 6.0f;
    [SerializeField] bool       m_noBlood = false;
    [SerializeField] GameObject m_slideDust;

    private Animator            m_animator;
    private Rigidbody2D         m_body2d;
    private Sensor_HeroKnight   m_groundSensor;
    private Sensor_HeroKnight   m_wallSensorR1;
    private Sensor_HeroKnight   m_wallSensorR2;
    private Sensor_HeroKnight   m_wallSensorL1;
    private Sensor_HeroKnight   m_wallSensorL2;
    private bool                m_isWallSliding = false;
    private bool                m_grounded = false;
    private bool                m_rolling = false;
    private int                 m_facingDirection = 1;
    private int                 m_currentAttack = 0;
    private float               m_timeSinceAttack = 0.0f;
    private float               m_delayToIdle = 0.0f;
    private float               m_rollDuration = 8.0f / 14.0f;
    private float               m_rollCurrentTime;


    // Use this for initialization
    void Start ()
    {
        m_animator = GetComponent<Animator>();
        m_body2d = GetComponent<Rigidbody2D>();
        m_groundSensor = transform.Find("GroundSensor").GetComponent<Sensor_HeroKnight>();
        m_wallSensorR1 = transform.Find("WallSensor_R1").GetComponent<Sensor_HeroKnight>();
        m_wallSensorR2 = transform.Find("WallSensor_R2").GetComponent<Sensor_HeroKnight>();
        m_wallSensorL1 = transform.Find("WallSensor_L1").GetComponent<Sensor_HeroKnight>();
        m_wallSensorL2 = transform.Find("WallSensor_L2").GetComponent<Sensor_HeroKnight>();
    }

    // Update is called once per frame
    void Update ()
    {
        // Increase timer that controls attack combo
        m_timeSinceAttack += Time.deltaTime;

        // Increase timer that checks roll duration
        if(m_rolling)
            m_rollCurrentTime += Time.deltaTime;

        // Disable rolling if timer extends duration
        if(m_rollCurrentTime > m_rollDuration)
            m_rolling = false;

        //Check if character just landed on the ground
        if (!m_grounded && m_groundSensor.State())
        {
            m_grounded = true;
            m_animator.SetBool("Grounded", m_grounded);
        }

        //Check if character just started falling
        if (m_grounded && !m_groundSensor.State())
        {
            m_grounded = false;
            m_animator.SetBool("Grounded", m_grounded);
        }

        // -- Handle input and movement --
        float inputX = Input.GetAxis("Horizontal");

        // Swap direction of sprite depending on walk direction
        if (inputX > 0)
        {
            GetComponent<SpriteRenderer>().flipX = false;
            m_facingDirection = 1;
        }
            
        else if (inputX < 0)
        {
            GetComponent<SpriteRenderer>().flipX = true;
            m_facingDirection = -1;
        }

        // Move
        if (!m_rolling )
            m_body2d.linearVelocity = new Vector2(inputX * m_speed, m_body2d.linearVelocity.y);

        //Set AirSpeed in animator
        m_animator.SetFloat("AirSpeedY", m_body2d.linearVelocity.y);

        // -- Handle Animations --
        //Wall Slide
        m_isWallSliding = (m_wallSensorR1.State() && m_wallSensorR2.State()) || (m_wallSensorL1.State() && m_wallSensorL2.State());
        m_animator.SetBool("WallSlide", m_isWallSliding);

        //Death
        if (Input.GetKeyDown("e") && !m_rolling)
        {
            m_animator.SetBool("noBlood", m_noBlood);
            m_animator.SetTrigger("Death");
        }
            
        //Hurt
        else if (Input.GetKeyDown("q") && !m_rolling)
            m_animator.SetTrigger("Hurt");

        //Attack
        else if(Input.GetMouseButtonDown(0) && m_timeSinceAttack > 0.25f && !m_rolling)
        {
            m_currentAttack++;

            // Loop back to one after third attack
            if (m_currentAttack > 3)
                m_currentAttack = 1;

            // Reset Attack combo if time since last attack is too large
            if (m_timeSinceAttack > 1.0f)
                m_currentAttack = 1;

            // Call one of three attack animations "Attack1", "Attack2", "Attack3"
            m_animator.SetTrigger("Attack" + m_currentAttack);

            // Reset timer
            m_timeSinceAttack = 0.0f;
        }

        // Block
        else if (Input.GetMouseButtonDown(1) && !m_rolling)
        {
            m_animator.SetTrigger("Block");
            m_animator.SetBool("IdleBlock", true);
        }

        else if (Input.GetMouseButtonUp(1))
            m_animator.SetBool("IdleBlock", false);

        // Roll
        else if (Input.GetKeyDown("left shift") && !m_rolling && !m_isWallSliding)
        {
            m_rolling = true;
            m_animator.SetTrigger("Roll");
            m_body2d.linearVelocity = new Vector2(m_facingDirection * m_rollForce, m_body2d.linearVelocity.y);
        }
            

        //Jump
        else if (Input.GetKeyDown("space") && m_grounded && !m_rolling)
        {
            m_animator.SetTrigger("Jump");
            m_grounded = false;
            m_animator.SetBool("Grounded", m_grounded);
            m_body2d.linearVelocity = new Vector2(m_body2d.linearVelocity.x, m_jumpForce);
            m_groundSensor.Disable(0.2f);
        }

        //Run
        else if (Mathf.Abs(inputX) > Mathf.Epsilon)
        {
            // Reset timer
            m_delayToIdle = 0.05f;
            m_animator.SetInteger("AnimState", 1);
        }

        //Idle
        else
        {
            // Prevents flickering transitions to idle
            m_delayToIdle -= Time.deltaTime;
                if(m_delayToIdle < 0)
                    m_animator.SetInteger("AnimState", 0);
        }
    }

    // Animation Events
    // Called in slide animation.
    void AE_SlideDust()
    {
        Vector3 spawnPosition;

        if (m_facingDirection == 1)
            spawnPosition = m_wallSensorR2.transform.position;
        else
            spawnPosition = m_wallSensorL2.transform.position;

        if (m_slideDust != null)
        {
            // Set correct arrow spawn position
            GameObject dust = Instantiate(m_slideDust, spawnPosition, gameObject.transform.localRotation) as GameObject;
            // Turn arrow in correct direction
            dust.transform.localScale = new Vector3(m_facingDirection, 1, 1);
        }
    }
}




// File: Sensor_HeroKnight.cs
//===========================================
using UnityEngine;
using System.Collections;

public class Sensor_HeroKnight : MonoBehaviour {

    private int m_ColCount = 0;

    private float m_DisableTimer;

    private void OnEnable()
    {
        m_ColCount = 0;
    }

    public bool State()
    {
        if (m_DisableTimer > 0)
            return false;
        return m_ColCount > 0;
    }

    void OnTriggerEnter2D(Collider2D other)
    {
        m_ColCount++;
    }

    void OnTriggerExit2D(Collider2D other)
    {
        m_ColCount--;
    }

    void Update()
    {
        m_DisableTimer -= Time.deltaTime;
    }

    public void Disable(float duration)
    {
        m_DisableTimer = duration;
    }
}




// File: CardData.cs
//===========================================
using UnityEngine;
using System.Collections.Generic;
using Cards;

[CreateAssetMenu(fileName = "NewCard", menuName = "Cards/Card Data")]
public class CardData : ScriptableObject
{
    [Header("Card Info")]
    [SerializeField] private string cardName;
    [SerializeField] private int cost;
    [SerializeField] private Sprite cardArt;
    [SerializeField] private string cardCategory;
    [SerializeField] private string cardDescription;

    [Header("Card Effect")]
    [SerializeField] private int effectValue;  
    [SerializeField, Tooltip("Assign a ScriptableObject that defines the effect. Required!")] 
    private CardEffect cardEffect;

    [Header("Status Effects (Optional)")]  
    [SerializeField] private List<StatusEffectData> statusEffects = new List<StatusEffectData>();  // Initialize list

    [Header("Class Bonuses")]
    [SerializeField] private CharacterClass preferredClass;
    [SerializeField] private float classBonus = 1.5f;

    [Header("Card Type")]
    [SerializeField] private CardType cardType;

    [Header("Audio")]  
    [SerializeField] private AudioClip soundEffect;  

    // üîπ Public Read-Only Properties
    public string CardName => cardName;
    public int Cost => cost;
    public Sprite CardArt => cardArt;
    public string CardDescription => cardDescription;
    public int EffectValue => effectValue;
    public CardEffect CardEffect => cardEffect;
    public List<StatusEffectData> StatusEffects => statusEffects;  // ‚úÖ Getter for status effects
    public CharacterClass PreferredClass => preferredClass;
    public float ClassBonus => classBonus;
    public CardType CardType => cardType;
    public AudioClip SoundEffect => soundEffect;

    // üîπ Validate in Editor to prevent missing data
    private void OnValidate()
    {
        if (cardEffect == null)
        {
            Debug.LogWarning($"[CardData] ‚ö†Ô∏è Card '{cardName}' is missing a CardEffect!");
        }

        if (statusEffects == null)
        {
            statusEffects = new List<StatusEffectData>();
            Debug.Log($"[CardData] Initialized status effects list for card '{cardName}'");
        }
    }
}





// File: CardEffect.cs
//===========================================
using UnityEngine;

public abstract class CardEffect : ScriptableObject
{
    public CardEffectData effectData;  // ‚úÖ Reference to effect data

    public EffectType EffectType => effectData.effectType;  // ‚úÖ Expose effectType
    public int EffectValue => effectData.baseValue;  // ‚úÖ Expose base value

    public abstract void ApplyEffect(IEffectTarget target, int value);
}






// File: CardEffectData.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "New Card Effect", menuName = "Game/Card Effect")]
public class CardEffectData : ScriptableObject
{
    public string effectName;
    public EffectType effectType;  // ‚úÖ Now correctly references effect type
    public int baseValue;          // Default value of the effect (e.g., 8 for Damage)
    public AudioClip effectSound;  // ‚úÖ Sound effect when applied

    [Header("Status Effect (Optional)")]
    public StatusEffectData statusEffectData;  // ‚úÖ Added reference to status effects
}




// File: CardSoundType.cs
//===========================================
namespace Cards
{
    public static class CardSoundEffects
    {
        public const string Draw = "CardDraw";
        public const string Play = "CardPlay";
        public const string Attack = "CardAttack";
        public const string Spell = "CardSpell";
        public const string Support = "CardSupport";
    }
}




// File: EffectType.cs
//===========================================
using UnityEngine;

public enum EffectType
{
    Damage,       // Deals damage to an enemy
    Heal,         // Restores health
    //Block,        // Grants temporary protection from damage
    Strength,     // Increases attack power
    //Weak,         // Reduces attack power
    //Vulnerable,   // Increases damage taken
    Energy,       // Grants extra energy
    CardDraw,     // Draws extra cards
    Exhaust,      // Removes a card from play for the rest of combat
    Power  // Applies a persistent effect
    //Status  // Generic category for unique effects
}




// File: StatusEffectData.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "New Status Effect", menuName = "Game/Status Effect")]
public class StatusEffectData : ScriptableObject
{
    public string effectName;
    public Sprite effectIcon;
    public string description;
    public StatusType statusType;   // ‚úÖ Uses the StatusType enum
    public int maxDuration;
    public AudioClip effectSound;
}



// File: APManager.cs
//===========================================
using UnityEngine;
using System;

public class APManager : MonoBehaviour
{
    public static APManager Instance { get; private set; }

    [SerializeField] private int maxAP = 6;  // Set max AP in the Inspector
    private int currentAP;

    public event Action<int> OnAPChanged; // üîπ Event for UI updates

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    private void Start()
    {
        ResetAP();
    }

    public void ResetAP()
    {
        currentAP = maxAP;
        OnAPChanged?.Invoke(currentAP);  // üîπ Notify UI
    }

    public bool SpendAP(int amount)
    {
        if (amount > currentAP)
        {
            Debug.LogWarning("[APManager] ‚ùå Not enough AP!");
            return false; 
        }

        currentAP -= amount;
        OnAPChanged?.Invoke(currentAP);  // üîπ Notify UI
        Debug.Log($"[APManager] üî• {amount} AP spent. Remaining: {currentAP}");
        return true;
    }

    public int GetCurrentAP() => currentAP;
}






// File: CardFanLayoutManager.cs
//===========================================
using UnityEngine;
using DG.Tweening;
using System.Collections.Generic;
using System.Linq;

public class CardFanLayoutManager : MonoBehaviour
{
    [Header("Fan Settings")]
    [SerializeField] private float curveRadius = 400f;     // Reduced from 1200f
    [SerializeField] private float fanAngle = 8f;          // Increased from 5f
    [SerializeField] private float cardSpacing = 80f;      // New: Controls horizontal spacing
    [SerializeField] private float arcHeight = 50f;        // Reduced from 100f
    [SerializeField] private float verticalOffset = 0f;

    [Header("Hover Animation")]
    [SerializeField] private float hoverLiftHeight = 50f;
    [SerializeField] private float hoverScale = 1.2f;
    [SerializeField] private float hoverDuration = 0.2f;
    [SerializeField] private Ease hoverEase = Ease.OutQuart;

    private Dictionary<GameObject, Vector3> cardBasePositions = new Dictionary<GameObject, Vector3>();
    private Dictionary<GameObject, Quaternion> cardBaseRotations = new Dictionary<GameObject, Quaternion>();

    public void ArrangeCards(List<GameObject> cards)
    {
        // Clear old positions for removed cards
        var keysToRemove = cardBasePositions.Keys
            .Where(card => !cards.Contains(card))
            .ToList();
            
        foreach (var key in keysToRemove)
        {
            cardBasePositions.Remove(key);
            cardBaseRotations.Remove(key);
        }

        int cardCount = cards.Count;
        if (cardCount == 0) return;

        // Recalculate positions for remaining cards
        for (int i = 0; i < cardCount; i++)
        {
            GameObject card = cards[i];
            Vector3 position = CalculateCardPosition(i, cardCount, cards);
            Quaternion rotation = Quaternion.Euler(0, 0, Mathf.Lerp(-fanAngle, fanAngle, (float)i / (cardCount - 1)));

            cardBasePositions[card] = position;
            cardBaseRotations[card] = rotation;

            // Animate to new position
            card.transform.DOKill(); // Kill any existing tweens
            card.transform.DOLocalMove(position, 0.3f).SetEase(Ease.OutQuad);
            card.transform.DOLocalRotate(rotation.eulerAngles, 0.3f).SetEase(Ease.OutQuad);
        }
    }

    private Vector3 CalculateCardPosition(int index, int totalCards, List<GameObject> cards)
    {
        // Calculate relative position in hand (0 to 1)
        float normalizedPosition = (float)index / (totalCards - 1);
        
        // Calculate horizontal position with tighter spacing
        float x = index * cardSpacing - ((totalCards - 1) * cardSpacing * 0.5f);
        
        // Calculate vertical arc (convex upward)
        float arcOffset = -(normalizedPosition * normalizedPosition - normalizedPosition) * arcHeight * 4f;
        float y = arcOffset + verticalOffset;
        
        // Calculate rotation (fans outward)
        float rotationAngle = Mathf.Lerp(-fanAngle, fanAngle, normalizedPosition);
        cardBaseRotations[cards[index]] = Quaternion.Euler(0, 0, rotationAngle);
        
        // Layer cards properly
        float z = -index * 0.01f;
        
        return new Vector3(x, y, z);
    }

    public void OnCardHover(GameObject card, bool isHovered)
    {
        if (!cardBasePositions.ContainsKey(card))
        {
            Debug.LogError($"[CardFanLayout] Card {card.name} not found in positions dictionary!");
            return;
        }

        // Kill any existing tweens on this card
        card.transform.DOKill();

        if (isHovered)
        {
            Debug.Log($"[CardFanLayout] Hovering card {card.name}");
            Vector3 hoverPosition = cardBasePositions[card] + Vector3.up * hoverLiftHeight;
            
            Sequence hoverSequence = DOTween.Sequence();
            hoverSequence.Join(card.transform.DOLocalMove(hoverPosition, hoverDuration))
                        .Join(card.transform.DOScale(Vector3.one * hoverScale, hoverDuration))
                        .Join(card.transform.DOLocalRotate(Vector3.zero, hoverDuration))
                        .SetEase(hoverEase);
        }
        else
        {
            Debug.Log($"[CardFanLayout] Unhovering card {card.name}");
            Sequence unhoverSequence = DOTween.Sequence();
            unhoverSequence.Join(card.transform.DOLocalMove(cardBasePositions[card], hoverDuration))
                          .Join(card.transform.DOScale(Vector3.one, hoverDuration))
                          .Join(card.transform.DOLocalRotate(cardBaseRotations[card].eulerAngles, hoverDuration))
                          .SetEase(hoverEase);
        }
    }

    private void OnDestroy()
    {
        DOTween.KillAll();
    }
}




// File: DeckManager.cs
//===========================================
using System.Collections.Generic;
using UnityEngine;

public class DeckManager : MonoBehaviour
{
    [SerializeField] private List<CardData> allCards;
    [SerializeField] private int deckSize = 20;  // Set fixed deck size
    public List<CardData> deck { get; private set; } = new List<CardData>();
    public List<CardData> discardPile { get; private set; } = new List<CardData>();
    public List<CardData> exhaustPile = new List<CardData>(); // ‚úÖ New Exhaust Pile


    private void Awake()
    {
        if (allCards == null || allCards.Count == 0)
        {
            Debug.LogError("[DeckManager] ‚ùå No cards assigned to allCards!");
            return;
        }
        
        InitializeDeck();
    }

    private void InitializeDeck()
    {
        deck.Clear();
        discardPile.Clear();

        // Fill deck up to deckSize, repeating cards if necessary
        for (int i = 0; i < deckSize; i++)
        {
            int randomIndex = Random.Range(0, allCards.Count);
            deck.Add(allCards[randomIndex]);
        }

        ShuffleDeck();
        Debug.Log($"[DeckManager] ‚úÖ Deck initialized with {deck.Count} cards");
    }

    public void ShuffleDeck()
    {
        // Fisher-Yates shuffle
        for (int i = deck.Count - 1; i > 0; i--)
        {
            int j = Random.Range(0, i + 1);
            var temp = deck[i];
            deck[i] = deck[j];
            deck[j] = temp;
        }
    }

    public void ReshuffleDeck()
    {
        Debug.Log($"[DeckManager] Reshuffling. Deck: {deck.Count}, Discard: {discardPile.Count}");
        deck.AddRange(discardPile);
        discardPile.Clear();
        ShuffleDeck();
        Debug.Log($"[DeckManager] üîÑ Deck reshuffled. New size: {deck.Count}");
    }

    public void ExhaustCard(CardData card)
    {
        if (card != null)
        {
            exhaustPile.Add(card);
            Debug.Log($"[DeckManager] üö´ Card '{card.CardName}' has been exhausted.");
        }
    }
}






// File: HandManager.cs
//===========================================
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class HandManager : MonoBehaviour
{
    [SerializeField] private Transform handArea;
    [SerializeField] private GameObject cardPrefab;
    [SerializeField] private DeckManager deckManager;
    [SerializeField] private int maxHandSize = 5;  // Changed default to 5 cards
    [SerializeField] private CardFanLayoutManager fanLayout;

    private List<GameObject> currentHand = new List<GameObject>();

    private void Start()
    {
        if (!ValidateSetup()) return;
        
        // Ensure hand area has proper layout
        if (handArea.GetComponent<HorizontalLayoutGroup>() == null)
        {
            HorizontalLayoutGroup layout = handArea.gameObject.AddComponent<HorizontalLayoutGroup>();
            layout.spacing = 10f;
            layout.childAlignment = TextAnchor.MiddleCenter;
            layout.childForceExpandWidth = false;
            layout.childForceExpandHeight = false;
        }
        
        DrawCards(maxHandSize);
    }

    private bool ValidateSetup()
    {
        if (handArea == null)
        {
            Debug.LogError("[HandManager] ‚ùå Hand Area not assigned!");
            return false;
        }
        if (cardPrefab == null)
        {
            Debug.LogError("[HandManager] ‚ùå Card Prefab not assigned!");
            return false;
        }
        if (deckManager == null)
        {
            Debug.LogError("[HandManager] ‚ùå DeckManager not assigned!");
            return false;
        }
        if (deckManager.deck == null || deckManager.deck.Count == 0)
        {
            Debug.LogError("[HandManager] ‚ùå Deck is empty or null!");
            return false;
        }
        Debug.Log("[HandManager] ‚úÖ Setup validated successfully");
        return true;
    }

    public void DrawCards(int number)
    {
        int desiredCards = Mathf.Min(number, maxHandSize - currentHand.Count);
        Debug.Log($"[HandManager] Drawing {desiredCards} cards. Current hand: {currentHand.Count}");

        // Reshuffle if needed before drawing
        if (deckManager.deck.Count < desiredCards)
        {
            deckManager.ReshuffleDeck();
        }

        for (int i = 0; i < desiredCards && deckManager.deck.Count > 0; i++)
        {
            GameObject cardObject = Instantiate(cardPrefab, handArea);
            CardBehavior cardBehavior = cardObject.GetComponent<CardBehavior>();
            
            // if (cardBehavior != null)
            // {
            //     cardBehavior.cardData = deckManager.deck[0];
            //     cardBehavior.UpdateCardDisplay();
            //     deckManager.deck.RemoveAt(0);
            //     currentHand.Add(cardObject);
            // }
            if (cardBehavior != null)
            {
                cardBehavior.Initialize(deckManager.deck[0]); // ‚úÖ Assign card data + update UI
                deckManager.deck.RemoveAt(0);
                currentHand.Add(cardObject);
                //AudioManager.Instance.PlaySound("CardDraw");
                Debug.Log($"[HandManager] ‚úÖ Added card: {cardBehavior.CardData.CardName}");
            }
        }

        LayoutRebuilder.ForceRebuildLayoutImmediate(handArea as RectTransform);
        
        // Arrange cards in fan layout
        fanLayout?.ArrangeCards(currentHand);
    }

    public void DiscardCard(GameObject card)
    {
        if (currentHand.Contains(card))
        {
            CardBehavior cardBehavior = card.GetComponent<CardBehavior>();
            if (cardBehavior != null && cardBehavior.CardData != null)
            {
                deckManager.discardPile.Add(cardBehavior.CardData);
            }
            currentHand.Remove(card);
            Destroy(card);
            
            // Rearrange remaining cards
            fanLayout?.ArrangeCards(currentHand);
            
            //AudioManager.Instance.PlaySound("CardDiscard");
            Debug.Log("[HandManager] üóëÔ∏è Card discarded and hand rearranged");
        }
    }

    public void ClearHand()
    {
        // Create a temporary list to store cards to be discarded
        List<CardData> cardsToDiscard = new List<CardData>();
        
        // First, collect all card data
        foreach (GameObject card in currentHand)
        {
            if (card != null)
            {
                CardBehavior cardBehavior = card.GetComponent<CardBehavior>();
                if (cardBehavior != null && cardBehavior.CardData != null)
                {
                    cardsToDiscard.Add(cardBehavior.CardData);
                }
            }
        }

        // Then destroy the game objects
        foreach (GameObject card in currentHand)
        {
            if (card != null)
            {
                Destroy(card);
            }
        }

        // Add collected cards to discard pile
        foreach (CardData cardData in cardsToDiscard)
        {
            deckManager.discardPile.Add(cardData);
        }

        currentHand.Clear();
        Debug.Log($"[HandManager] üßπ Hand cleared, added {cardsToDiscard.Count} cards to discard pile");
    }

    public void RefreshHand()
    {
        ClearHand();
        deckManager.ReshuffleDeck();
        DrawCards(maxHandSize);
        Debug.Log($"[HandManager] üîÑ Hand refreshed to {currentHand.Count}/{maxHandSize} cards");
    }

    public void ExhaustCard(GameObject card)
    {
        if (currentHand.Contains(card))
        {
            CardBehavior cardBehavior = card.GetComponent<CardBehavior>();
            if (cardBehavior != null && cardBehavior.CardData != null)
            {
                // Move the card to the exhaust pile instead of discard
                deckManager.ExhaustCard(cardBehavior.CardData);
            }

            // Remove from hand and destroy the card UI
            currentHand.Remove(card);
            Destroy(card);
            
            // Rearrange remaining cards
            fanLayout?.ArrangeCards(currentHand);

            Debug.Log($"[HandManager] üö´ Exhausted card '{cardBehavior.CardData.CardName}'");
        }
    }

    public void ExhaustRandomCard()
    {
        if (currentHand.Count == 0) return;

        int randomIndex = Random.Range(0, currentHand.Count);
        GameObject cardToExhaust = currentHand[randomIndex];

        Debug.Log($"[HandManager] üö´ Randomly exhausting '{cardToExhaust.GetComponent<CardBehavior>().CardData.CardName}'");
        
        ExhaustCard(cardToExhaust);
    }


    public void OnCardHover(GameObject card, bool isHovered)
    {
        fanLayout?.OnCardHover(card, isHovered);
    }
}





// File: CardDisplay.cs
//===========================================
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class CardDisplay : MonoBehaviour
{
    [Header("Required Text Elements")]
    [SerializeField] private TextMeshProUGUI cardNameText;
    [SerializeField] private TextMeshProUGUI costText;

    [Header("Optional Text Elements")]
    [SerializeField] private TextMeshProUGUI descriptionText;

    [Header("Visual Elements")]
    [SerializeField] private Image artworkImage;
    [SerializeField] private Image cardFrame;
    [SerializeField] private GameObject selectionHighlight;

    private void Awake()
    {
        ValidateComponents();
        if (selectionHighlight != null)
        {
            selectionHighlight.SetActive(false);
        }
    }

    public void UpdateCardVisual(CardData cardData)
    {
        if (cardData == null)
        {
            Debug.LogError("[CardDisplay] ‚ùå CardData is null!");
            return;
        }

        // Update required elements
        if (cardNameText) cardNameText.text = cardData.CardName;
        if (costText) costText.text = cardData.Cost.ToString();
        
        // Update optional description if available
        if (descriptionText != null)
        {
            descriptionText.text = cardData.CardDescription;
        }
        
        // Update artwork
        if (artworkImage && cardData.CardArt)
        {
            artworkImage.sprite = cardData.CardArt;
            artworkImage.preserveAspect = true;
        }

        Debug.Log($"[CardDisplay] Updated card visual for: {cardData.CardName}");
    }

    private void ValidateComponents()
    {
        if (!cardNameText) Debug.LogError("[CardDisplay] Missing card name text component!");
        if (!costText) Debug.LogError("[CardDisplay] Missing cost text component!");
        if (!artworkImage) Debug.LogError("[CardDisplay] Missing artwork image component!");
        
        // Description text is optional, just log a warning
        if (!descriptionText) Debug.LogWarning("[CardDisplay] Description text component not assigned - description will not be displayed.");
    }

    public void SetSelectionHighlight(bool isActive)
    {
        if (selectionHighlight != null)
        {
            selectionHighlight.SetActive(isActive);
        }
    }

    // Validate components in editor
    private void OnValidate()
    {
        if (!cardNameText || !costText || !descriptionText || !artworkImage)
        {
            Debug.LogWarning("[CardDisplay] Some UI elements are not assigned in inspector!");
        }
    }
}





// File: IEffectTarget.cs
//===========================================
public interface IEffectTarget
{
    void ApplyEffect(int value, EffectType type); //, StatusEffectData effectData = null);
}





// File: CardType.cs
//===========================================
namespace Cards
{
    public enum CardType
    {
        None,
        Attack,
        Spell,
        Support
    }
}




// File: BaseCharacter.cs
//===========================================
using UnityEngine;
using System.Collections.Generic;

public abstract class BaseCharacter : MonoBehaviour, ICharacter, IEffectTarget
{
    public string Name { get; protected set; }
    public CharacterStats Stats { get; private set; }

    [SerializeField] private int health;
    [SerializeField] private int block;
    [SerializeField] private int strength;
    [SerializeField] private int energy;

    public CharacterCombat Combat { get; private set; }

    private bool isSelected = false;
    public bool IsSelected => isSelected;
    private static BaseCharacter currentlySelectedCharacter;

    protected virtual void Awake()
    {
        Stats = GetComponent<CharacterStats>();
        Combat = GetComponent<CharacterCombat>();
    }

    public virtual void TakeDamage(int damage) => Stats.ModifyHealth(-damage);
    public virtual void Heal(int amount) => Stats.ModifyHealth(amount);
    public virtual void UseActionPoints(int amount) => Stats.UseActionPoints(amount);

    public List<StatusEffects> statusEffects = new List<StatusEffects>();
    public List<ActiveStatusEffect> activeEffects = new List<ActiveStatusEffect>();

    public delegate void OnEffectUpdated();
    public event OnEffectUpdated EffectUpdated;  // ‚úÖ Triggers UI update when effects change

    public void ModifyStrength(int amount)
    {
        strength += amount;
        Debug.Log($"{Name} gained {amount} Strength.");
    }

    public void GainEnergy(int amount)
    {
        energy += amount;
        Debug.Log($"{Name} gained {amount} Energy.");
    }

    public void DrawCards(int amount)
    {
        //DeckManager.DrawCards(amount);
    }

    public void ExhaustCard()
    {
        //HandManager.ExhaustRandomCard();
    }

    public void ApplyPowerEffect(int value)
    {
        // Powers are persistent effects. You can implement them here.
        //PowerManager.Instance.ApplyPowerEffect(this, value);
    }

    // ‚úÖ Apply Status Effects
    public void ApplyStatusEffect(StatusEffectData effect, int duration)
    {
        ActiveStatusEffect existingEffect = activeEffects.Find(e => e.effectData == effect);
        if (existingEffect != null)
        {
            existingEffect.duration = Mathf.Max(existingEffect.duration, duration);
        }
        else
        {
            activeEffects.Add(new ActiveStatusEffect(effect, duration));
        }

        if (effect.effectSound != null)
        {
            AudioSource.PlayClipAtPoint(effect.effectSound, transform.position);
        }

        Debug.Log($"{Name} gained {effect.effectName} for {duration} turns.");
        EffectUpdated?.Invoke();

        // ‚úÖ Debug active effects
        DebugStatusEffects();
    }


    public void RemoveEffect(StatusEffectData effect)
    {
        activeEffects.RemoveAll(e => e.effectData == effect);
        EffectUpdated?.Invoke();
    }

    // ‚úÖ Reduce Status Effect Durations (Call at end of turn)
    public void ProcessEndOfTurnEffects()
    {
        foreach (var effect in activeEffects)
        {
            effect.duration--;
        }
        activeEffects.RemoveAll(e => e.duration <= 0);
        EffectUpdated?.Invoke();
    }
    public void ApplyEffect(int value, EffectType type)
    {
        switch (type)
        {
            case EffectType.Damage:
                TakeDamage(value);
                Debug.Log($"{Name} took {value} damage.");
                break;

            case EffectType.Heal:
                Heal(value);
                Debug.Log($"{Name} healed {value} HP.");
                break;

            case EffectType.Energy:
                GainEnergy(value);
                Debug.Log($"{Name} gained {value} energy.");
                break;

            case EffectType.CardDraw:
                DrawCards(value);
                Debug.Log($"{Name} drew {value} cards.");
                break;

            case EffectType.Exhaust:
                ExhaustCard();
                Debug.Log($"{Name} exhausted a card.");
                break;

            case EffectType.Power:
                ApplyPowerEffect(value);
                Debug.Log($"{Name} activated a persistent power.");
                break;
        }
    }


    public virtual void Select()
    {
        // Deselect current character if one exists and it's not this one
        if (currentlySelectedCharacter != null && currentlySelectedCharacter != this)
        {
            currentlySelectedCharacter.Deselect();
        }

        // Only set as selected if not already selected
        if (!IsSelected)
        {
            currentlySelectedCharacter = this;
            isSelected = true;
            Debug.Log($"[BaseCharacter] Selected character: {Name} (Class: {Stats.CharacterClass})");
        }
    }

    public virtual void Deselect()
    {
        if (IsSelected)
        {
            currentlySelectedCharacter = null;
            isSelected = false;
            Debug.Log($"[BaseCharacter] Deselected character: {Name}");
        }
    }

    public static BaseCharacter GetSelectedCharacter() => currentlySelectedCharacter;

    public void DebugStatusEffects()
    {
        Debug.Log($"[BaseCharacter] {Name} Status Effects:");

        if (statusEffects.Count == 0)
        {
            Debug.Log(" - No active status effects.");
            return;
        }

        foreach (var effect in statusEffects)
        {
            Debug.Log($" - {effect.Type} (Duration: {effect.Duration} turns)");
        }
    }

    public void EndTurn()
    {
        Debug.Log($"[BaseCharacter] {Name} ending turn...");

        for (int i = statusEffects.Count - 1; i >= 0; i--)
        {
            statusEffects[i].Duration--;

            if (statusEffects[i].Duration <= 0)
            {
                Debug.Log($"{Name} lost {statusEffects[i].Type} effect.");
                statusEffects.RemoveAt(i);
            }
        }

        // ‚úÖ Log updated effects
        DebugStatusEffects();
    }

}


// ‚úÖ Helper class to store effect data + duration
[System.Serializable]
public class ActiveStatusEffect
{
    public StatusEffectData effectData;
    public int duration;

    public ActiveStatusEffect(StatusEffectData data, int dur)
    {
        effectData = data;
        duration = dur;
    }
}



// File: CharacterClass.cs
//===========================================
public enum CharacterClass
{
    None,
    Knight,
    Mage,
    Healer,
    Rogue
}




// File: EnemyUnit.cs
//===========================================
using UnityEngine;
using System.Collections;

public class EnemyUnit : BaseCharacter
{
    [SerializeField] private EnemyIntentUI intentUI;
    private EnemyAnimationController animationController;

    protected override void Awake()
    {
        base.Awake();
        Name = "Enemy";

        // Get or find intent UI
        if (intentUI == null)
        {
            intentUI = GetComponentInChildren<EnemyIntentUI>(true); // Include inactive objects
        }
        if (intentUI == null)
        {
            Debug.LogError("[EnemyUnit] ‚ùå EnemyIntentUI not found!");
        }
        else
        {
            // Ensure it starts hidden but initialized
            intentUI.gameObject.SetActive(true);
            intentUI.HideIntent();
        }

        animationController = GetComponentInChildren<EnemyAnimationController>();
        if (animationController == null)
        {
            Debug.LogError("[EnemyUnit] ‚ùå EnemyAnimationController not found!");
        }
    }

    public void ShowIntent(CardData card)
    {
        intentUI?.ShowIntent(card);
    }

    public void HideIntent()
    {
        intentUI?.HideIntent();
    }

    public IEnumerator AttackPlayer(BaseCharacter player)
    {
        if (animationController == null)
        {
            Debug.LogError("[EnemyUnit] ‚ùå No Animation Controller found, skipping animation.");
            yield break;
        }

        Debug.Log($"[EnemyUnit] ‚öîÔ∏è Enemy is attacking {player.Name}!");

        // ‚úÖ Play enemy attack animation
        yield return StartCoroutine(animationController.PlayAttackSequence(player.transform.position));

        // ‚úÖ Apply damage after attack animation
        player.TakeDamage(5);
        Debug.Log($"[EnemyUnit] üî• {player.Name} took 5 damage!");
    }

    private void OnValidate()
    {
        if (intentUI == null)
        {
            intentUI = GetComponentInChildren<EnemyIntentUI>();
            if (intentUI == null)
            {
                Debug.LogWarning("[EnemyUnit] ‚ö†Ô∏è EnemyIntentUI component needs to be assigned!");
            }
        }
    }
}





// File: PlayerUnit.cs
//===========================================
using UnityEngine;

[RequireComponent(typeof(CharacterStats))]
[RequireComponent(typeof(CharacterCombat))]
public class PlayerUnit : BaseCharacter
{
    [SerializeField] private Material outlineMaterial;
    private Material defaultMaterial;
    private Renderer characterRenderer; // Changed from SpriteRenderer to Renderer to work with both 2D and 3D

    private CharacterStats stats;
    private CharacterCombat combat;

    protected override void Awake()
    {
        base.Awake();
        Name = "Player";

        // Get required components
        stats = GetComponent<CharacterStats>();
        combat = GetComponent<CharacterCombat>();
        
        // Look for renderer in children
        characterRenderer = GetComponentInChildren<Renderer>();

        if (characterRenderer != null)
        {
            defaultMaterial = characterRenderer.sharedMaterial;
            Debug.Log($"[PlayerUnit] Found {characterRenderer.GetType().Name} in {characterRenderer.gameObject.name} and stored default material: {defaultMaterial?.name ?? "null"}");
        }
        else
        {
            Debug.LogError("[PlayerUnit] ‚ùå No renderer component found in children! Check hierarchy for MeshRenderer or SpriteRenderer.");
        }

        if (outlineMaterial == null)
        {
            Debug.LogError("[PlayerUnit] ‚ùå Outline material not assigned in inspector!");
        }
    }

    public override void Select()
    {
        // Validate components before selection
        if (characterRenderer == null)
        {
            Debug.LogError("[PlayerUnit] ‚ùå Cannot select: Missing renderer component!");
            return;
        }

        if (outlineMaterial == null)
        {
            Debug.LogError("[PlayerUnit] ‚ùå Cannot select: Missing outline material!");
            return;
        }

        if (!IsSelected)
        {
            characterRenderer.material = outlineMaterial;
            base.Select();
            Debug.Log($"[PlayerUnit] Applied outline material to {Name}");
        }
    }

    public override void Deselect()
    {
        if (IsSelected)  // Only proceed if currently selected
        {
            if (characterRenderer != null && defaultMaterial != null)
            {
                characterRenderer.material = defaultMaterial;
                base.Deselect();  // Call base.Deselect() after restoring material
                Debug.Log($"[PlayerUnit] Restored default material to {Name}");
            }
        }
    }

    // Add validation in inspector
    private void OnValidate()
    {
        if (outlineMaterial == null)
        {
            Debug.LogWarning("[PlayerUnit] ‚ö†Ô∏è Outline material needs to be assigned!");
        }
    }
}





// File: StatusEffect.cs
//===========================================
using UnityEngine;

public enum StatusType
{
    Weak,
    Vulnerable,
    Poison,
    StrengthBuff,
    Destabilized,
    Exhausted
}

public class StatusEffects
{
    public StatusType Type;
    public int Duration;

    public StatusEffects(StatusType type, int duration)
    {
        Type = type;
        Duration = duration;
    }
}




// File: CharacterAnimationController.cs
//===========================================
using UnityEngine;
using System.Collections;

public class CharacterAnimationController : MonoBehaviour
{
    [SerializeField] protected Animator animator;
    [SerializeField] protected float moveSpeed = 3f;
    [SerializeField] protected float attackDistance = 1.5f;
    [SerializeField] protected float attackDuration = 1f;

    protected Vector3 originalPosition;
    protected bool isAnimating = false;

    protected virtual void Awake()
    {
        if (animator == null)
        {
            animator = GetComponentInChildren<Animator>();
        }
        originalPosition = transform.position;
    }

    public virtual IEnumerator MoveToTarget(Vector3 targetPosition, bool returnToStart = false)
    {
        Vector3 startPos = transform.position;
        Vector3 destination = targetPosition;

        // Start movement animation
        animator.SetBool("IsMoving", true);
        
        while (Vector3.Distance(transform.position, destination) > 0.1f)
        {
            transform.position = Vector3.MoveTowards(
                transform.position,
                destination,
                moveSpeed * Time.deltaTime
            );
            yield return null;
        }
        
        // Ensure exact position and stop movement animation
        transform.position = destination;
        animator.SetBool("IsMoving", false);
    }

    public virtual IEnumerator PlayAttackSequence(Vector3 targetPosition)
    {
        if (isAnimating) yield break;
        isAnimating = true;

        // Move to attack position
        Vector3 attackPosition = Vector3.MoveTowards(targetPosition, transform.position, attackDistance);
        yield return StartCoroutine(MoveToTarget(attackPosition));

        // Wait a frame to ensure movement is complete
        yield return null;

        // Play attack animation
        animator.SetTrigger("AttackStrike");
        
        // Wait for attack animation
        float attackStateLength = GetAnimationLength("AttackStrike");
        yield return new WaitForSeconds(attackStateLength);

        // Return to starting position
        yield return StartCoroutine(MoveToTarget(originalPosition, true));

        // Reset to idle
        animator.SetTrigger("Idle");

        isAnimating = false;
    }

    protected float GetAnimationLength(string stateName)
    {
        AnimatorStateInfo stateInfo = animator.GetCurrentAnimatorStateInfo(0);
        return stateInfo.length;
    }

    protected virtual void OnValidate()
    {
        if (moveSpeed <= 0) moveSpeed = 3f;
        if (attackDistance <= 0) attackDistance = 1.5f;
        if (attackDuration <= 0) attackDuration = 1f;
    }
}




// File: EnemyAnimationController.cs
//===========================================
using UnityEngine;
using System.Collections;

public class EnemyAnimationController : MonoBehaviour
{
    [SerializeField] private Animator animator;
    [SerializeField] private float moveSpeed = 3f;
    [SerializeField] private float attackDistance = 1.5f;
    [SerializeField] private float attackDuration = 1f;
    
    private Vector3 originalPosition;
    public Vector3 OriginalPosition => originalPosition;
    private bool isAnimating = false;

    private void Awake()
    {
        if (animator == null)
        {
            animator = GetComponentInChildren<Animator>();
        }
        
        originalPosition = transform.position;
        Debug.Log($"[EnemyAnimationController] Original position set to: {originalPosition}");
    }

    public IEnumerator MoveToTarget(Vector3 targetPosition, bool returnToStart = false)
    {
        Vector3 startPos = transform.position;
        Vector3 destination = targetPosition;

        // Start moving
        animator.SetBool("IsMoving", true);
        
        while (Vector3.Distance(transform.position, destination) > 0.1f)
        {
            transform.position = Vector3.MoveTowards(
                transform.position,
                destination,
                moveSpeed * Time.deltaTime
            );
            yield return null;
        }
        
        // Ensure exact position and stop moving
        transform.position = destination;
        animator.SetBool("IsMoving", false);
        
        Debug.Log($"[EnemyAnimationController] Moved to {(returnToStart ? "original position" : "target")}");
    }

    public IEnumerator PlayAttackSequence(Vector3 targetPosition)
    {
        if (isAnimating) yield break;
        isAnimating = true;

        Debug.Log("[EnemyAnimationController] Starting attack sequence");

        // Move to attack position
        Vector3 attackPosition = Vector3.MoveTowards(targetPosition, transform.position, attackDistance);
        yield return StartCoroutine(MoveToTarget(attackPosition));

        // Wait a frame to ensure movement animation is complete
        yield return null;

        // Play attack animation
        animator.SetTrigger("AttackStrike");
        Debug.Log("[EnemyAnimationController] Playing attack animation");
        
        // Wait for attack animation to complete
        float attackStateLength = GetAnimationLength("AttackStrike");
        yield return new WaitForSeconds(attackStateLength);

        // Return to original position
        yield return StartCoroutine(MoveToTarget(originalPosition, true));

        // Wait a frame to ensure movement is complete
        yield return null;

        // Reset to idle
        animator.SetTrigger("Idle");
        Debug.Log("[EnemyAnimationController] Returned to idle state");

        isAnimating = false;
    }

    private float GetAnimationLength(string stateName)
    {
        AnimatorStateInfo stateInfo = animator.GetCurrentAnimatorStateInfo(0);
        return stateInfo.length;
    }

    private void OnValidate()
    {
        if (moveSpeed <= 0) moveSpeed = 3f;
        if (attackDistance <= 0) attackDistance = 1.5f;
        if (attackDuration <= 0) attackDuration = 1f;
    }
}




// File: EnemyUnitClickHandler.cs
//===========================================
using UnityEngine;

public class EnemyUnitClickHandler : MonoBehaviour
{
    private EnemyUnit enemyUnit;

    private void Awake()
    {
        enemyUnit = GetComponent<EnemyUnit>();
        if (enemyUnit == null)
        {
            Debug.LogError("[EnemyUnitClickHandler] ‚ùå EnemyUnit component not found on " + gameObject.name);
        }
    }

    private void OnMouseDown()
    {
        if (enemyUnit == null)
        {
            Debug.LogWarning("[EnemyUnitClickHandler] ‚ö†Ô∏è EnemyUnit is null.");
            return;
        }

        // Check if a card is selected
        CardBehavior selectedCard = CardSelection.GetSelectedCard();
        CardExecution cardExecution = selectedCard?.GetComponent<CardExecution>();
        if (selectedCard != null)
        {
            cardExecution.PlayCard(enemyUnit); // Apply card effect
        }
        else
        {
            Debug.Log($"[EnemyUnitClickHandler] üëä No card selected. Dealing 5 test damage to {enemyUnit.Name}.");
            enemyUnit.TakeDamage(5); // Default behavior for testing
        }
    }
}




// File: PlayerUnitClickHandler.cs
//===========================================
using UnityEngine;
using UnityEngine.EventSystems;

[RequireComponent(typeof(PlayerUnit))]
public class PlayerUnitClickHandler : MonoBehaviour
{
    private PlayerUnit playerUnit;

    private void Awake()
    {
        playerUnit = GetComponent<PlayerUnit>();
    }

    private void OnMouseDown()
    {
        if (playerUnit == null) return;

        if (!playerUnit.IsSelected)
        {
            Debug.Log($"[PlayerUnitClickHandler] üëÜ Selecting {playerUnit.Name} ({playerUnit.Stats.CharacterClass})");
            playerUnit.Select();
        }
        else
        {
            Debug.Log($"[PlayerUnitClickHandler] üëá Deselecting {playerUnit.Name}");
            playerUnit.Deselect();
        }
    }
}




// File: CharacterCombat.cs
//===========================================
using UnityEngine;

public class CharacterCombat : MonoBehaviour
{
    public void ExecuteAttack(ICharacter target, int damage)
    {
        target.TakeDamage(damage);
    }
}




// File: CharacterStats.cs
//===========================================
using UnityEngine;
using System;

public class CharacterStats : MonoBehaviour
{
    [Header("Data Source")]
    [SerializeField] private CharacterData characterData;  // ScriptableObject for base stats

    [Header("Base Stats")]
    [SerializeField] private int maxHealth;               // Exposed in Inspector
    [SerializeField] private int startingActionPoints;    // Exposed in Inspector

    public int MaxHealth { get; private set; }
    public int CurrentHealth { get; private set; }
    public int MaxActionPoints { get; private set; }
    public int CurrentActionPoints { get; private set; }
    public CharacterClass CharacterClass { get; private set; }
    public float ClassBonus { get; private set; }

    // ‚úÖ Events for Health & Action Points
    public event Action<int> OnHealthChanged;
    public event Action<int> OnActionPointsChanged;

    private void Awake()
    {
        ApplyCharacterData();  // Apply values from ScriptableObject
        Initialize(maxHealth, startingActionPoints);
    }

    public void Initialize(int maxHealth, int actionPoints)
    {
        MaxHealth = maxHealth;
        CurrentHealth = maxHealth;

        MaxActionPoints = actionPoints;
        CurrentActionPoints = actionPoints;

        // Trigger UI updates
        OnHealthChanged?.Invoke(CurrentHealth);
        OnActionPointsChanged?.Invoke(CurrentActionPoints);
    }

    // ‚úÖ HEALTH MANAGEMENT
    public void ModifyHealth(int amount)
    {
        int previousHealth = CurrentHealth;
        CurrentHealth = Mathf.Clamp(CurrentHealth + amount, 0, MaxHealth);
        Debug.Log($"[CharacterStats] ‚ù§Ô∏è Health changed from {previousHealth} to {CurrentHealth} (Change: {amount})");
        OnHealthChanged?.Invoke(CurrentHealth);
    }

    // ‚úÖ ACTION POINTS MANAGEMENT
    public void UseActionPoints(int amount)
    {
        int previousAP = CurrentActionPoints;
        CurrentActionPoints = Mathf.Max(0, CurrentActionPoints - amount);
        Debug.Log($"[CharacterStats] ‚ö° AP changed from {previousAP} to {CurrentActionPoints} (Used: {amount})");
        OnActionPointsChanged?.Invoke(CurrentActionPoints);
    }

    public void RefreshActionPoints()
    {
        CurrentActionPoints = MaxActionPoints;
        Debug.Log($"[CharacterStats] üîÑ Action Points refreshed to {CurrentActionPoints}");
        OnActionPointsChanged?.Invoke(CurrentActionPoints);
    }

    // ‚úÖ Automatically update values in the Inspector during Edit Mode
    private void OnValidate()
    {
        ApplyCharacterData();
    }

    // Apply data from the ScriptableObject to the exposed fields
    private void ApplyCharacterData()
    {
        if (characterData != null)
        {
            maxHealth = characterData.maxHealth;
            startingActionPoints = characterData.startingActionPoints;
            CharacterClass = characterData.characterClass;
            ClassBonus = characterData.classBonus;
        }
    }
}




// File: CharacterData.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "NewCharacterData", menuName = "Game/Character Data")]
public class CharacterData : ScriptableObject
{
    [Header("Base Stats")]
    [SerializeField] public int maxHealth = 100;
    [SerializeField] public int startingActionPoints = 3;
    

    [Header("Character Info")]
    [SerializeField] public string characterName;
    [TextArea]
    [SerializeField] public string description;

    [Header("Class Settings")]
    public CharacterClass characterClass;
    public float classBonus = 1.0f;
}




// File: ICharacter.cs
//===========================================
public interface ICharacter
{
    string Name { get; }
    CharacterStats Stats { get; }
    CharacterCombat Combat { get; }

    void TakeDamage(int damage);
    void Heal(int amount);
    void UseActionPoints(int amount);
}




// File: TurnManager.cs
//===========================================
using UnityEngine;
using System;

public class TurnManager : MonoBehaviour
{
    public static TurnManager Instance { get; private set; }
    
    public enum TurnState { PlayerTurn, EnemyTurn }
    public TurnState CurrentTurn { get; private set; } = TurnState.PlayerTurn;
    
    public event Action<TurnState> OnTurnChanged;

    [SerializeField] private HandManager handManager;  // Assign in inspector

    private void Awake()
    {
        if (Instance == null)
            Instance = this;
        else
            Destroy(gameObject);
    }

    private void Start()
    {
        StartPlayerTurn();
    }

    public void EndPlayerTurn()
    {
        // Deselect current character if one exists
        BaseCharacter selectedChar = BaseCharacter.GetSelectedCharacter();
        if (selectedChar != null)
        {
            selectedChar.Deselect();
        }

        Debug.Log("[TurnManager] üîÑ Player turn ended");
        CurrentTurn = TurnState.EnemyTurn;
        OnTurnChanged?.Invoke(CurrentTurn);
        StartEnemyTurn();
    }

    private void StartEnemyTurn()
    {
        Debug.Log("[TurnManager] üëø Enemy turn started");
        if (EnemyAIManager.Instance != null)
        {
            EnemyAIManager.Instance.ExecuteEnemyTurn();
        }
        else
        {
            Debug.LogError("[TurnManager] ‚ùå No EnemyAIManager found in scene!");
            EndEnemyTurn();
        }
    }

    public void EndEnemyTurn()
    {
        Debug.Log("[TurnManager] Enemy turn ended");
        CurrentTurn = TurnState.PlayerTurn;
        OnTurnChanged?.Invoke(CurrentTurn);

        Debug.Log("[TurnManager] Ending turn...");

        // ‚úÖ Find all characters and process their end-turn status effects
        BaseCharacter[] allCharacters = FindObjectsByType<BaseCharacter>(FindObjectsSortMode.None);
        foreach (BaseCharacter character in allCharacters)
        {
            character.EndTurn();
        }

        Debug.Log("[TurnManager] --- Turn Ended ---");

        StartPlayerTurn();
    }

    private void StartPlayerTurn()
    {
        Debug.Log("[TurnManager] üëë Player turn started");
        APManager.Instance.ResetAP();
        
        if (handManager != null)
        {
            handManager.RefreshHand(); // Use RefreshHand instead of just drawing
            Debug.Log("[TurnManager] üé¥ Hand refreshed for turn start");
        }
        else
        {
            Debug.LogError("[TurnManager] ‚ùå HandManager reference missing!");
        }
    }
}




// File: APBarUI.cs
//===========================================
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class APBarUI : MonoBehaviour
{
    [SerializeField] private Image apFillImage;  // üîπ Reference to the AP bar fill (Image)
    [SerializeField] private TextMeshProUGUI apText; // UI text for displaying AP amount
    private int maxAP;

    private void Start()
    {
        if (APManager.Instance != null)
        {
            maxAP = APManager.Instance.GetCurrentAP();  // Get initial max AP
            APManager.Instance.OnAPChanged += UpdateAPDisplay;
            UpdateAPDisplay(maxAP); // Initialize
        }
        else
        {
            Debug.LogError("[APBarUI] ‚ùå APManager not found in scene!");
        }
    }

    private void UpdateAPDisplay(int currentAP)
    {
        if (apFillImage != null)
        {
            apFillImage.fillAmount = (float)currentAP / maxAP;  // üîπ Adjust fill amount
        }
        
        if (apText != null)
        {
            apText.text = $"AP: {currentAP} / {maxAP}"; // üîπ Update AP text
        }
    }
}




// File: HealthBarUI.cs
//===========================================
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class HealthBarUI : MonoBehaviour
{
    [SerializeField] private Image healthFill;  // Reference to UI Image component
    [SerializeField] private TextMeshProUGUI healthText;  // Add reference to TMP text
    private BaseCharacter character;
    private CharacterStats characterStats;

    private void Awake()
    {
        // Configure Image component
        if (healthFill != null)
        {
            healthFill.type = Image.Type.Filled;
            healthFill.fillMethod = Image.FillMethod.Horizontal;
            healthFill.fillOrigin = (int)Image.OriginHorizontal.Left;
        }

        // Step 1: Find the BaseCharacter (PlayerUnit/EnemyUnit)
        character = GetComponentInParent<BaseCharacter>();
        if (character == null)
        {
            Debug.LogError("[HealthBarUI] ‚ùå BaseCharacter not found in parent of " + gameObject.name);
            return;
        }

        // Step 2: Try to find CharacterStats directly or in the parent
        characterStats = character.GetComponent<CharacterStats>();
        if (characterStats == null)
        {
            characterStats = GetComponentInParent<CharacterStats>(); // Look further up if needed
        }

        if (characterStats == null)
        {
            Debug.LogError("[HealthBarUI] ‚ùå CharacterStats not found for " + character.Name);
            return;
        }

        // Subscribe to health changes
        characterStats.OnHealthChanged += UpdateHealthBar;

        // Verify Image setup
        if (healthFill != null)
        {
            if (healthFill.type != Image.Type.Filled)
            {
                Debug.LogError("[HealthBarUI] ‚ùå Image type must be set to FILLED!");
                return;
            }
        }
    }

    private void Start()
    {
        if (characterStats != null)
        {
            if (healthFill != null)
            {
                UpdateHealthBar(characterStats.CurrentHealth);
            }
            else
            {
                Debug.LogError("[HealthBarUI] ‚ùå Health fill Image reference is missing!");
            }
        }
    }

    private void UpdateHealthBar(int currentHealth)
    {
        if (healthFill == null)
        {
            Debug.LogError("[HealthBarUI] Health fill Image reference not assigned.");
            return;
        }

        // Update fill amount
        float fillAmount = (float)currentHealth / characterStats.MaxHealth;
        healthFill.fillAmount = fillAmount;

        // Update text display
        if (healthText != null)
        {
            healthText.text = $"{currentHealth}/{characterStats.MaxHealth}";
        }

    }

    private void OnDestroy()
    {
        if (characterStats != null)
        {
            characterStats.OnHealthChanged -= UpdateHealthBar;
        }
    }
}






// File: EndTurnButton.cs
//===========================================
using UnityEngine;
using UnityEngine.UI;
using TMPro;

[RequireComponent(typeof(Button))]
public class EndTurnButton : MonoBehaviour
{
    private Button button;
    [SerializeField] private TextMeshProUGUI buttonText;

    private void Awake()
    {
        button = GetComponent<Button>();
        button.onClick.AddListener(OnEndTurnClicked);
    }

    private void Start()
    {
        if (TurnManager.Instance != null)
        {
            TurnManager.Instance.OnTurnChanged += UpdateButtonState;
            UpdateButtonState(TurnManager.Instance.CurrentTurn);
        }
        else
        {
            Debug.LogError("[EndTurnButton] ‚ùå No TurnManager instance found!");
            button.interactable = false;
        }
    }

    private void OnEnable()
    {
        // Moved to Start
    }

    private void OnDisable()
    {
        if (TurnManager.Instance != null)
            TurnManager.Instance.OnTurnChanged -= UpdateButtonState;
    }

    private void OnEndTurnClicked()
    {
        TurnManager.Instance.EndPlayerTurn();
    }

    private void UpdateButtonState(TurnManager.TurnState newTurn)
    {
        button.interactable = (newTurn == TurnManager.TurnState.PlayerTurn);
        buttonText.text = newTurn == TurnManager.TurnState.PlayerTurn ? "End Turn" : "Enemy Turn";
    }
}




// File: BlockEffect.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "BlockEffect", menuName = "Cards/Effects/Block")]
public class BlockEffect : CardEffect
{
    public override void ApplyEffect(IEffectTarget target, int value)
    {
        //target.ApplyEffect(value, EffectType.Block);
    }
}




// File: CardDrawEffect.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "CardDrawEffect", menuName = "Cards/Effects/CardDraw")]
public class CardDrawEffect : CardEffect
{
    public override void ApplyEffect(IEffectTarget target, int value)
    {
        target.ApplyEffect(value, EffectType.CardDraw);
    }
}




// File: DamageEffect.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "DamageEffect", menuName = "Cards/Effects/Damage")]
public class DamageEffect : CardEffect
{
    public override void ApplyEffect(IEffectTarget target, int value)
    {
        target.ApplyEffect(value, EffectType.Damage);
    }
}




// File: EnergyEffect.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "EnergyEffect", menuName = "Cards/Effects/Energy")]
public class EnergyEffect : CardEffect
{
    public override void ApplyEffect(IEffectTarget target, int value)
    {
        target.ApplyEffect(value, EffectType.Energy);
    }
}




// File: ExhaustEffect.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "ExhaustEffect", menuName = "Cards/Effects/Exhaust")]
public class ExhaustEffect : CardEffect
{
    public override void ApplyEffect(IEffectTarget target, int value)
    {
        target.ApplyEffect(value, EffectType.Exhaust);
    }
}




// File: HealEffect.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "HealEffect", menuName = "Cards/Effects/Heal")]
public class HealEffect : CardEffect
{
    public override void ApplyEffect(IEffectTarget target, int value)
    {
        target.ApplyEffect(value, EffectType.Heal);
    }
}




// File: PowerEffect.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "PowerEffect", menuName = "Cards/Effects/Power")]
public class PowerEffect : CardEffect
{
    public override void ApplyEffect(IEffectTarget target, int value)
    {
        target.ApplyEffect(value, EffectType.Power);
    }
}




// File: StatusEffect.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "StatusEffect", menuName = "Cards/Effects/Status")]
public class StatusEffect : CardEffect
{
    public override void ApplyEffect(IEffectTarget target, int value)
    {
        //target.ApplyEffect(value, EffectType.Status);
    }
}




// File: StrengthEffect.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "StrengthEffect", menuName = "Cards/Effects/Strength")]
public class StrengthEffect : CardEffect
{
    public override void ApplyEffect(IEffectTarget target, int value)
    {
        target.ApplyEffect(value, EffectType.Strength);
    }
}




// File: VulnerableEffect.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "VulnerableEffect", menuName = "Cards/Effects/Vulnerable")]
public class VulnerableEffect : CardEffect
{
    public override void ApplyEffect(IEffectTarget target, int value)
    {
        //target.ApplyEffect(value, EffectType.Vulnerable);
    }
}




// File: WeakEffect.cs
//===========================================
using UnityEngine;

[CreateAssetMenu(fileName = "WeakEffect", menuName = "Cards/Effects/Weak")]
public class WeakEffect : CardEffect
{
    public override void ApplyEffect(IEffectTarget target, int value)
    {
        //target.ApplyEffect(value, EffectType.Weak);
    }
}




// File: CardBehavior.cs
//===========================================
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using Cards;

public class CardBehavior : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
{
    [SerializeField] private CardData cardData;
    [SerializeField] private Image cardBackground;
    public CardData CardData => cardData;
    private HandManager handManager;

    private void Awake()
    {
        // Setup components
        if (cardBackground == null)
        {
            cardBackground = GetComponent<Image>();
        }

        // Setup UI interaction
        var canvasGroup = GetComponent<CanvasGroup>();
        if (canvasGroup == null)
        {
            canvasGroup = gameObject.AddComponent<CanvasGroup>();
        }
        canvasGroup.blocksRaycasts = true;
        canvasGroup.interactable = true;

        foreach (var image in GetComponentsInChildren<Image>())
        {
            image.raycastTarget = true;
        }

        // Find HandManager in hierarchy
        FindHandManager();
    }

    private void FindHandManager()
    {
        // First try to find HandManager in scene
        handManager = FindFirstObjectByType<HandManager>();
        
        if (handManager == null)
        {
            Debug.LogError($"[CardBehavior] Could not find HandManager in scene! Make sure HandManager component exists.");
        }
        else
        {
            Debug.Log($"[CardBehavior] Found HandManager on {handManager.gameObject.name}");
        }
    }

    public void Initialize(CardData newCardData)
    {
        cardData = newCardData;
        UpdateCardColor();
        CardDisplay display = GetComponent<CardDisplay>();
        if (display != null)
        {
            display.UpdateCardVisual(cardData);
        }
    }

    private void UpdateCardColor()
    {
        if (cardBackground == null || cardData == null) return;

        cardBackground.color = GetColorForType(cardData.CardType);
    }

    private Color GetColorForType(CardType type)
    {
        return type switch
        {
            CardType.Attack => new Color(1f, 0.6f, 0.6f),  // Light red
            CardType.Spell => new Color(0.6f, 0.6f, 1f),   // Light blue
            CardType.Support => new Color(0.6f, 1f, 0.6f), // Light green
            _ => Color.white
        };
    }

    public void PlayCardSound()
    {
        if (AudioManager.Instance != null && cardData != null && cardData.SoundEffect != null)
        {
            AudioManager.Instance.PlaySound(cardData.SoundEffect);  
            Debug.Log($"[CardBehavior] üéµ Playing sound: {cardData.SoundEffect.name}");
        }
        else
        {
            Debug.LogWarning("[CardBehavior] ‚ùå Cannot play sound - Missing AudioManager, CardData, or SoundEffect!");
        }
    }

    public void OnPointerEnter(PointerEventData eventData)
    {
        if (handManager == null)
        {
            FindHandManager();
            if (handManager == null) return;
        }
        // Debug.Log($"[CardBehavior] Hover ENTER on {gameObject.name}");
        handManager.OnCardHover(gameObject, true);
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        if (handManager == null) return;
        Debug.Log($"[CardBehavior] Hover EXIT on {gameObject.name}");
        handManager.OnCardHover(gameObject, false);
    }
}




// File: CardExecution.cs
//===========================================
using UnityEngine;
using System.Collections;

public class CardExecution : MonoBehaviour
{
    private CardBehavior cardBehavior;

    private void Awake()
    {
        cardBehavior = GetComponent<CardBehavior>();
        if (cardBehavior == null)
        {
            Debug.LogError("[CardExecution] ‚ùå CardBehavior component is missing!");
        }
    }

    public void PlayCard(IEffectTarget target)
    {
        if (!ValidatePlayConditions()) return;

        BaseCharacter sourceCharacter = BaseCharacter.GetSelectedCharacter();
        if (sourceCharacter == null)
        {
            Debug.LogWarning("[CardExecution] ‚ùå No character selected to play card!");
            return;
        }

        int finalValue = GetFinalEffectValue(sourceCharacter);
        
        // ‚úÖ Play sound before applying effect
        if (cardBehavior != null)
        {
            cardBehavior.PlayCardSound();
        }

        // ‚úÖ Play attack animation before applying effect
        StartCoroutine(PerformAttackSequence(target, finalValue));
    }


    /// <summary>
    /// ‚úÖ Moves the character, plays animation, then applies effect.
    /// </summary>
    private IEnumerator PerformAttackSequence(IEffectTarget target, int finalValue)
    {
        if (target == null)
        {
            Debug.LogError("Target is null in PerformAttackSequence");
            yield break;
        }

        BaseCharacter sourceCharacter = BaseCharacter.GetSelectedCharacter();
        if (sourceCharacter == null)
        {
            Debug.LogError("[CardExecution] ‚ùå No character selected to perform attack.");
            yield break;
        }

        // ‚úÖ Get animation controller from source character
        CharacterAnimationController animationController = sourceCharacter.GetComponentInChildren<CharacterAnimationController>();

        if (animationController == null)
        {
            Debug.LogError($"[CardExecution] ‚ùå CharacterAnimationController is missing on {sourceCharacter.Name}!");
            yield break;
        }

        // ‚úÖ Move forward and perform attack
        Vector3 targetPosition = ((MonoBehaviour)target).transform.position;
        yield return StartCoroutine(animationController.PlayAttackSequence(targetPosition));

        // ‚úÖ Apply effect after animation completes
        try
        {
            ApplyCardEffect(target, finalValue);
        }
        catch (System.Exception e)
        {
            Debug.LogError($"Error in PerformAttackSequence: {e.Message}");
        }

        // ‚úÖ Remove card from hand and destroy it
        HandManager handManager = FindAnyObjectByType<HandManager>();
        if (handManager != null)
        {
            handManager.DiscardCard(gameObject);
            Debug.Log("[CardExecution] Card removed from hand and discarded");
        }
    }


    private bool ValidatePlayConditions()
    {
        if (TurnManager.Instance.CurrentTurn != TurnManager.TurnState.PlayerTurn)
        {
            Debug.LogWarning("[CardExecution] ‚ùå Cannot play cards during enemy turn!");
            return false;
        }

        if (cardBehavior == null || cardBehavior.CardData == null)
        {
            Debug.LogError("[CardExecution] ‚ùå CardBehavior or CardData is missing.");
            return false;
        }

        if (!APManager.Instance.SpendAP(cardBehavior.CardData.Cost))
        {
            Debug.LogWarning($"[CardExecution] ‚ùå Not enough AP to play {cardBehavior.CardData.CardName}");
            return false;
        }

        return true;
    }

    private int GetFinalEffectValue(BaseCharacter sourceCharacter)
    {
        int baseValue = cardBehavior.CardData.EffectValue;
        float multiplier = (sourceCharacter.Stats.CharacterClass == cardBehavior.CardData.PreferredClass)
            ? cardBehavior.CardData.ClassBonus
            : 1.0f;

        int finalValue = Mathf.RoundToInt(baseValue * multiplier);
        Debug.Log($"[CardExecution] Damage calculation: {baseValue} √ó {multiplier} = {finalValue}");
        return finalValue;
    }

    private void ApplyCardEffect(IEffectTarget target, int finalValue)
    {
        if (target == null)
        {
            Debug.LogError("[CardExecution] ‚ùå Target is NULL in ApplyCardEffect");
            return;
        }

        if (cardBehavior == null)
        {
            Debug.LogError("[CardExecution] ‚ùå cardBehavior is NULL in ApplyCardEffect");
            return;
        }

        if (cardBehavior.CardData == null)
        {
            Debug.LogError($"[CardExecution] ‚ùå CardData is NULL in {cardBehavior.name}");
            return;
        }

        if (cardBehavior.CardData.CardEffect == null)
        {
            Debug.LogError($"[CardExecution] ‚ùå CardEffect is NULL in {cardBehavior.CardData.CardName}");
            return;
        }

        CardEffect effect = cardBehavior.CardData.CardEffect;
        if (effect == null)
        {
            Debug.LogError($"[CardExecution] ‚ùå effect is NULL in {cardBehavior.CardData.CardName}");
            return;
        }

        if (effect.effectData == null)
        {
            Debug.LogError($"[CardExecution] ‚ùå effectData is NULL in {effect.name}");
            return;
        }


        BaseCharacter targetCharacter = target as BaseCharacter;
        if (targetCharacter == null)
        {
            Debug.LogError("[CardExecution] ‚ùå Target is not a valid BaseCharacter");
            return;
        }

        Debug.Log($"‚úÖ [CardExecution] {BaseCharacter.GetSelectedCharacter()?.Name} played {cardBehavior.CardData.CardName}");

        // ‚úÖ Apply the main card effect (damage, block, etc.)
        try
        {
            Debug.Log($"üîπ Applying {effect.GetType().Name} effect to {targetCharacter.Name}");
            targetCharacter.ApplyEffect(finalValue, effect.EffectType);
        }
        catch (System.Exception e)
        {
            Debug.LogError($"‚ùå Error applying primary effect: {e.Message}\nStack trace: {e.StackTrace}");
        }

        // ‚úÖ Apply any status effects attached to the card
        if (cardBehavior.CardData.StatusEffects != null && cardBehavior.CardData.StatusEffects.Count > 0)
        {
            foreach (var statusEffect in cardBehavior.CardData.StatusEffects)
            {
                if (statusEffect == null)
                {
                    Debug.LogError($"‚ùå Null status effect detected in {cardBehavior.CardData.CardName}");
                    continue;
                }

                if (statusEffect.maxDuration <= 0)
                {
                    Debug.LogError($"‚ùå Invalid duration for {statusEffect.name}: {statusEffect.maxDuration}");
                    continue;
                }

                Debug.Log($"üîπ Applying status effect {statusEffect.effectName} to {targetCharacter.Name}");
                targetCharacter.ApplyStatusEffect(statusEffect, statusEffect.maxDuration);
            }
        }
        else
        {
            Debug.Log($"üîπ No status effects found for {cardBehavior.CardData.CardName}");
        }
    }

}




// File: CardSelection.cs
//===========================================
using UnityEngine;
using UnityEngine.EventSystems;
using System;

/// <summary>
/// Handles selecting and deselecting a card.
/// </summary>
public class CardSelection : MonoBehaviour, IPointerClickHandler
{
    private static CardBehavior currentlySelectedCard;
    private bool isSelected = false;
    public static event Action<CardBehavior> OnCardSelected;
    public static event Action<CardBehavior> OnCardDeselected;

    private CardBehavior cardBehavior;
    private CardDisplay cardDisplay; // ‚úÖ Reference to CardDisplay

    public bool IsSelected => isSelected;

    private void Awake()
    {
        cardBehavior = GetComponent<CardBehavior>();
        cardDisplay = GetComponent<CardDisplay>(); // ‚úÖ Get reference to display

        DeselectCard(); // Ensure it's deselected initially
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        if (cardBehavior == null)
        {
            Debug.LogError("[CardSelection] ‚ùå No CardBehavior found on this object!");
            return;
        }

        if (currentlySelectedCard == cardBehavior)
        {
            DeselectCard();
        }
        else
        {
            SelectCard();
        }
    }

    private void SelectCard()
    {
        if (currentlySelectedCard != null)
        {
            currentlySelectedCard.GetComponent<CardSelection>().DeselectCard();
        }

        isSelected = true;
        currentlySelectedCard = cardBehavior;

        cardDisplay?.SetSelectionHighlight(true); // ‚úÖ Notify CardDisplay

        OnCardSelected?.Invoke(cardBehavior);
    }

    private void DeselectCard()
    {
        if (!isSelected) return;

        isSelected = false;
        cardDisplay?.SetSelectionHighlight(false); // ‚úÖ Notify CardDisplay

        OnCardDeselected?.Invoke(cardBehavior);

        if (currentlySelectedCard == cardBehavior)
        {
            currentlySelectedCard = null;
        }
    }

    public static CardBehavior GetSelectedCard()
    {
        return currentlySelectedCard;
    }
}





// File: DOTweenModuleAudio.cs
//===========================================
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

#if true // MODULE_MARKER
using System;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using UnityEngine;
using UnityEngine.Audio; // Required for AudioMixer

#pragma warning disable 1591
namespace DG.Tweening
{
	public static class DOTweenModuleAudio
    {
        #region Shortcuts

        #region Audio

        /// <summary>Tweens an AudioSource's volume to the given value.
        /// Also stores the AudioSource as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach (0 to 1)</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<float, float, FloatOptions> DOFade(this AudioSource target, float endValue, float duration)
        {
            if (endValue < 0) endValue = 0;
            else if (endValue > 1) endValue = 1;
            TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.volume, x => target.volume = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens an AudioSource's pitch to the given value.
        /// Also stores the AudioSource as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<float, float, FloatOptions> DOPitch(this AudioSource target, float endValue, float duration)
        {
            TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.pitch, x => target.pitch = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #endregion

        #region AudioMixer

        /// <summary>Tweens an AudioMixer's exposed float to the given value.
        /// Also stores the AudioMixer as the tween's target so it can be used for filtered operations.
        /// Note that you need to manually expose a float in an AudioMixerGroup in order to be able to tween it from an AudioMixer.</summary>
        /// <param name="floatName">Name given to the exposed float to set</param>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<float, float, FloatOptions> DOSetFloat(this AudioMixer target, string floatName, float endValue, float duration)
        {
            TweenerCore<float, float, FloatOptions> t = DOTween.To(()=> {
                    float currVal;
                    target.GetFloat(floatName, out currVal);
                    return currVal;
                }, x=> target.SetFloat(floatName, x), endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #region Operation Shortcuts

        /// <summary>
        /// Completes all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens completed
        /// (meaning the tweens that don't have infinite loops and were not already complete)
        /// </summary>
        /// <param name="withCallbacks">For Sequences only: if TRUE also internal Sequence callbacks will be fired,
        /// otherwise they will be ignored</param>
        public static int DOComplete(this AudioMixer target, bool withCallbacks = false)
        {
            return DOTween.Complete(target, withCallbacks);
        }

        /// <summary>
        /// Kills all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens killed.
        /// </summary>
        /// <param name="complete">If TRUE completes the tween before killing it</param>
        public static int DOKill(this AudioMixer target, bool complete = false)
        {
            return DOTween.Kill(target, complete);
        }

        /// <summary>
        /// Flips the direction (backwards if it was going forward or viceversa) of all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens flipped.
        /// </summary>
        public static int DOFlip(this AudioMixer target)
        {
            return DOTween.Flip(target);
        }

        /// <summary>
        /// Sends to the given position all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens involved.
        /// </summary>
        /// <param name="to">Time position to reach
        /// (if higher than the whole tween duration the tween will simply reach its end)</param>
        /// <param name="andPlay">If TRUE will play the tween after reaching the given position, otherwise it will pause it</param>
        public static int DOGoto(this AudioMixer target, float to, bool andPlay = false)
        {
            return DOTween.Goto(target, to, andPlay);
        }

        /// <summary>
        /// Pauses all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens paused.
        /// </summary>
        public static int DOPause(this AudioMixer target)
        {
            return DOTween.Pause(target);
        }

        /// <summary>
        /// Plays all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens played.
        /// </summary>
        public static int DOPlay(this AudioMixer target)
        {
            return DOTween.Play(target);
        }

        /// <summary>
        /// Plays backwards all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens played.
        /// </summary>
        public static int DOPlayBackwards(this AudioMixer target)
        {
            return DOTween.PlayBackwards(target);
        }

        /// <summary>
        /// Plays forward all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens played.
        /// </summary>
        public static int DOPlayForward(this AudioMixer target)
        {
            return DOTween.PlayForward(target);
        }

        /// <summary>
        /// Restarts all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens restarted.
        /// </summary>
        public static int DORestart(this AudioMixer target)
        {
            return DOTween.Restart(target);
        }

        /// <summary>
        /// Rewinds all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens rewinded.
        /// </summary>
        public static int DORewind(this AudioMixer target)
        {
            return DOTween.Rewind(target);
        }

        /// <summary>
        /// Smoothly rewinds all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens rewinded.
        /// </summary>
        public static int DOSmoothRewind(this AudioMixer target)
        {
            return DOTween.SmoothRewind(target);
        }

        /// <summary>
        /// Toggles the paused state (plays if it was paused, pauses if it was playing) of all tweens that have this target as a reference
        /// (meaning tweens that were started from this target, or that had this target added as an Id)
        /// and returns the total number of tweens involved.
        /// </summary>
        public static int DOTogglePause(this AudioMixer target)
        {
            return DOTween.TogglePause(target);
        }

        #endregion

        #endregion

        #endregion
    }
}
#endif




// File: DOTweenModuleEPOOutline.cs
//===========================================
using UnityEngine;

#if false || EPO_DOTWEEN // MODULE_MARKER

using EPOOutline;
using DG.Tweening.Plugins.Options;
using DG.Tweening;
using DG.Tweening.Core;

namespace DG.Tweening
{
    public static class DOTweenModuleEPOOutline
    {
        public static int DOKill(this SerializedPass target, bool complete)
        {
            return DOTween.Kill(target, complete);
        }

        public static TweenerCore<float, float, FloatOptions> DOFloat(this SerializedPass target, string propertyName, float endValue, float duration)
        {
            var tweener = DOTween.To(() => target.GetFloat(propertyName), x => target.SetFloat(propertyName, x), endValue, duration);
            tweener.SetOptions(true).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Color, Color, ColorOptions> DOFade(this SerializedPass target, string propertyName, float endValue, float duration)
        {
            var tweener = DOTween.ToAlpha(() => target.GetColor(propertyName), x => target.SetColor(propertyName, x), endValue, duration);
            tweener.SetOptions(true).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Color, Color, ColorOptions> DOColor(this SerializedPass target, string propertyName, Color endValue, float duration)
        {
            var tweener = DOTween.To(() => target.GetColor(propertyName), x => target.SetColor(propertyName, x), endValue, duration);
            tweener.SetOptions(false).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Vector4, Vector4, VectorOptions> DOVector(this SerializedPass target, string propertyName, Vector4 endValue, float duration)
        {
            var tweener = DOTween.To(() => target.GetVector(propertyName), x => target.SetVector(propertyName, x), endValue, duration);
            tweener.SetOptions(false).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<float, float, FloatOptions> DOFloat(this SerializedPass target, int propertyId, float endValue, float duration)
        {
            var tweener = DOTween.To(() => target.GetFloat(propertyId), x => target.SetFloat(propertyId, x), endValue, duration);
            tweener.SetOptions(true).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Color, Color, ColorOptions> DOFade(this SerializedPass target, int propertyId, float endValue, float duration)
        {
            var tweener = DOTween.ToAlpha(() => target.GetColor(propertyId), x => target.SetColor(propertyId, x), endValue, duration);
            tweener.SetOptions(true).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Color, Color, ColorOptions> DOColor(this SerializedPass target, int propertyId, Color endValue, float duration)
        {
            var tweener = DOTween.To(() => target.GetColor(propertyId), x => target.SetColor(propertyId, x), endValue, duration);
            tweener.SetOptions(false).SetTarget(target);
            return tweener;
        }

        public static TweenerCore<Vector4, Vector4, VectorOptions> DOVector(this SerializedPass target, int propertyId, Vector4 endValue, float duration)
        {
            var tweener = DOTween.To(() => target.GetVector(propertyId), x => target.SetVector(propertyId, x), endValue, duration);
            tweener.SetOptions(false).SetTarget(target);
            return tweener;
        }

        public static int DOKill(this Outlinable.OutlineProperties target, bool complete = false)
        {
            return DOTween.Kill(target, complete);
        }

        public static int DOKill(this Outliner target, bool complete = false)
        {
            return DOTween.Kill(target, complete);
        }

        /// <summary>
        /// Controls the alpha (transparency) of the outline
        /// </summary>
        public static TweenerCore<Color, Color, ColorOptions> DOFade(this Outlinable.OutlineProperties target, float endValue, float duration)
        {
            var tweener = DOTween.ToAlpha(() => target.Color, x => target.Color = x, endValue, duration);
            tweener.SetOptions(true).SetTarget(target);
            return tweener;
        }

        /// <summary>
        /// Controls the color of the outline
        /// </summary>
        public static TweenerCore<Color, Color, ColorOptions> DOColor(this Outlinable.OutlineProperties target, Color endValue, float duration)
        {
            var tweener = DOTween.To(() => target.Color, x => target.Color = x, endValue, duration);
            tweener.SetOptions(false).SetTarget(target);
            return tweener;
        }

        /// <summary>
        /// Controls the amount of blur applied to the outline
        /// </summary>
        public static TweenerCore<float, float, FloatOptions> DOBlurShift(this Outlinable.OutlineProperties target, float endValue, float duration, bool snapping = false)
        {
            var tweener = DOTween.To(() => target.BlurShift, x => target.BlurShift = x, endValue, duration);
            tweener.SetOptions(snapping).SetTarget(target);
            return tweener;
        }

        /// <summary>
        /// Controls the amount of blur applied to the outline
        /// </summary>
        public static TweenerCore<float, float, FloatOptions> DOBlurShift(this Outliner target, float endValue, float duration, bool snapping = false)
        {
            var tweener = DOTween.To(() => target.BlurShift, x => target.BlurShift = x, endValue, duration);
            tweener.SetOptions(snapping).SetTarget(target);
            return tweener;
        }

        /// <summary>
        /// Controls the amount of dilation applied to the outline
        /// </summary>
        public static TweenerCore<float, float, FloatOptions> DODilateShift(this Outlinable.OutlineProperties target, float endValue, float duration, bool snapping = false)
        {
            var tweener = DOTween.To(() => target.DilateShift, x => target.DilateShift = x, endValue, duration);
            tweener.SetOptions(snapping).SetTarget(target);
            return tweener;
        }

        /// <summary>
        /// Controls the amount of dilation applied to the outline
        /// </summary>
        public static TweenerCore<float, float, FloatOptions> DODilateShift(this Outliner target, float endValue, float duration, bool snapping = false)
        {
            var tweener = DOTween.To(() => target.DilateShift, x => target.DilateShift = x, endValue, duration);
            tweener.SetOptions(snapping).SetTarget(target);
            return tweener;
        }
    }
}
#endif




// File: DOTweenModulePhysics.cs
//===========================================
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

#if true // MODULE_MARKER
using System;
using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using UnityEngine;

#pragma warning disable 1591
namespace DG.Tweening
{
	public static class DOTweenModulePhysics
    {
        #region Shortcuts

        #region Rigidbody

        /// <summary>Tweens a Rigidbody's position to the given value.
        /// Also stores the rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOMove(this Rigidbody target, Vector3 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody's X position to the given value.
        /// Also stores the rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOMoveX(this Rigidbody target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, new Vector3(endValue, 0, 0), duration);
            t.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody's Y position to the given value.
        /// Also stores the rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOMoveY(this Rigidbody target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, new Vector3(0, endValue, 0), duration);
            t.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody's Z position to the given value.
        /// Also stores the rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOMoveZ(this Rigidbody target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, new Vector3(0, 0, endValue), duration);
            t.SetOptions(AxisConstraint.Z, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody's rotation to the given value.
        /// Also stores the rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="mode">Rotation mode</param>
        public static TweenerCore<Quaternion, Vector3, QuaternionOptions> DORotate(this Rigidbody target, Vector3 endValue, float duration, RotateMode mode = RotateMode.Fast)
        {
            TweenerCore<Quaternion, Vector3, QuaternionOptions> t = DOTween.To(() => target.rotation, target.MoveRotation, endValue, duration);
            t.SetTarget(target);
            t.plugOptions.rotateMode = mode;
            return t;
        }

        /// <summary>Tweens a Rigidbody's rotation so that it will look towards the given position.
        /// Also stores the rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="towards">The position to look at</param><param name="duration">The duration of the tween</param>
        /// <param name="axisConstraint">Eventual axis constraint for the rotation</param>
        /// <param name="up">The vector that defines in which direction up is (default: Vector3.up)</param>
        public static TweenerCore<Quaternion, Vector3, QuaternionOptions> DOLookAt(this Rigidbody target, Vector3 towards, float duration, AxisConstraint axisConstraint = AxisConstraint.None, Vector3? up = null)
        {
            TweenerCore<Quaternion, Vector3, QuaternionOptions> t = DOTween.To(() => target.rotation, target.MoveRotation, towards, duration)
                .SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetLookAt);
            t.plugOptions.axisConstraint = axisConstraint;
            t.plugOptions.up = (up == null) ? Vector3.up : (Vector3)up;
            return t;
        }

        #region Special

        /// <summary>Tweens a Rigidbody's position to the given value, while also applying a jump effect along the Y axis.
        /// Returns a Sequence instead of a Tweener.
        /// Also stores the Rigidbody as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param>
        /// <param name="jumpPower">Power of the jump (the max height of the jump is represented by this plus the final Y offset)</param>
        /// <param name="numJumps">Total number of jumps</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Sequence DOJump(this Rigidbody target, Vector3 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
        {
            if (numJumps < 1) numJumps = 1;
            float startPosY = 0;
            float offsetY = -1;
            bool offsetYSet = false;
            Sequence s = DOTween.Sequence();
            Tween yTween = DOTween.To(() => target.position, target.MovePosition, new Vector3(0, jumpPower, 0), duration / (numJumps * 2))
                .SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetRelative()
                .SetLoops(numJumps * 2, LoopType.Yoyo)
                .OnStart(() => startPosY = target.position.y);
            s.Append(DOTween.To(() => target.position, target.MovePosition, new Vector3(endValue.x, 0, 0), duration)
                    .SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)
                ).Join(DOTween.To(() => target.position, target.MovePosition, new Vector3(0, 0, endValue.z), duration)
                    .SetOptions(AxisConstraint.Z, snapping).SetEase(Ease.Linear)
                ).Join(yTween)
                .SetTarget(target).SetEase(DOTween.defaultEaseType);
            yTween.OnUpdate(() => {
                if (!offsetYSet) {
                    offsetYSet = true;
                    offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                }
                Vector3 pos = target.position;
                pos.y += DOVirtual.EasedValue(0, offsetY, yTween.ElapsedPercentage(), Ease.OutQuad);
                target.MovePosition(pos);
            });
            return s;
        }

        /// <summary>Tweens a Rigidbody's position through the given path waypoints, using the chosen path algorithm.
        /// Also stores the Rigidbody as the tween's target so it can be used for filtered operations.
        /// <para>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</para>
        /// <para>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
        /// If you plan to publish there you should use a regular transform.DOPath.</para></summary>
        /// <param name="path">The waypoints to go through</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="pathType">The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)</param>
        /// <param name="pathMode">The path mode: 3D, side-scroller 2D, top-down 2D</param>
        /// <param name="resolution">The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
        /// Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints</param>
        /// <param name="gizmoColor">The color of the path (shown when gizmos are active in the Play panel and the tween is running)</param>
        public static TweenerCore<Vector3, Path, PathOptions> DOPath(
            this Rigidbody target, Vector3[] path, float duration, PathType pathType = PathType.Linear,
            PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null
        )
        {
            if (resolution < 1) resolution = 1;
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => target.position, target.MovePosition, new Path(pathType, path, resolution, gizmoColor), duration)
                .SetTarget(target).SetUpdate(UpdateType.Fixed);

            t.plugOptions.isRigidbody = true;
            t.plugOptions.mode = pathMode;
            return t;
        }
        /// <summary>Tweens a Rigidbody's localPosition through the given path waypoints, using the chosen path algorithm.
        /// Also stores the Rigidbody as the tween's target so it can be used for filtered operations
        /// <para>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</para>
        /// <para>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
        /// If you plan to publish there you should use a regular transform.DOLocalPath.</para></summary>
        /// <param name="path">The waypoint to go through</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="pathType">The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)</param>
        /// <param name="pathMode">The path mode: 3D, side-scroller 2D, top-down 2D</param>
        /// <param name="resolution">The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
        /// Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints</param>
        /// <param name="gizmoColor">The color of the path (shown when gizmos are active in the Play panel and the tween is running)</param>
        public static TweenerCore<Vector3, Path, PathOptions> DOLocalPath(
            this Rigidbody target, Vector3[] path, float duration, PathType pathType = PathType.Linear,
            PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null
        )
        {
            if (resolution < 1) resolution = 1;
            Transform trans = target.transform;
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => trans.localPosition, x => target.MovePosition(trans.parent == null ? x : trans.parent.TransformPoint(x)), new Path(pathType, path, resolution, gizmoColor), duration)
                .SetTarget(target).SetUpdate(UpdateType.Fixed);

            t.plugOptions.isRigidbody = true;
            t.plugOptions.mode = pathMode;
            t.plugOptions.useLocalPosition = true;
            return t;
        }
        // Used by path editor when creating the actual tween, so it can pass a pre-compiled path
        internal static TweenerCore<Vector3, Path, PathOptions> DOPath(
            this Rigidbody target, Path path, float duration, PathMode pathMode = PathMode.Full3D
        )
        {
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => target.position, target.MovePosition, path, duration)
                .SetTarget(target);

            t.plugOptions.isRigidbody = true;
            t.plugOptions.mode = pathMode;
            return t;
        }
        internal static TweenerCore<Vector3, Path, PathOptions> DOLocalPath(
            this Rigidbody target, Path path, float duration, PathMode pathMode = PathMode.Full3D
        )
        {
            Transform trans = target.transform;
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => trans.localPosition, x => target.MovePosition(trans.parent == null ? x : trans.parent.TransformPoint(x)), path, duration)
                .SetTarget(target);

            t.plugOptions.isRigidbody = true;
            t.plugOptions.mode = pathMode;
            t.plugOptions.useLocalPosition = true;
            return t;
        }

        #endregion

        #endregion

        #endregion
	}
}
#endif




// File: DOTweenModulePhysics2D.cs
//===========================================
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

#if true // MODULE_MARKER
using System;
using DG.Tweening.Core;
using DG.Tweening.Plugins;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using UnityEngine;

#pragma warning disable 1591
namespace DG.Tweening
{
	public static class DOTweenModulePhysics2D
    {
        #region Shortcuts

        #region Rigidbody2D Shortcuts

        /// <summary>Tweens a Rigidbody2D's position to the given value.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOMove(this Rigidbody2D target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody2D's X position to the given value.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOMoveX(this Rigidbody2D target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, new Vector2(endValue, 0), duration);
            t.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody2D's Y position to the given value.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOMoveY(this Rigidbody2D target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.position, target.MovePosition, new Vector2(0, endValue), duration);
            t.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Rigidbody2D's rotation to the given value.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<float, float, FloatOptions> DORotate(this Rigidbody2D target, float endValue, float duration)
        {
            TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.rotation, target.MoveRotation, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #region Special

        /// <summary>Tweens a Rigidbody2D's position to the given value, while also applying a jump effect along the Y axis.
        /// Returns a Sequence instead of a Tweener.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
        /// <para>IMPORTANT: a rigidbody2D can't be animated in a jump arc using MovePosition, so the tween will directly set the position</para></summary>
        /// <param name="endValue">The end value to reach</param>
        /// <param name="jumpPower">Power of the jump (the max height of the jump is represented by this plus the final Y offset)</param>
        /// <param name="numJumps">Total number of jumps</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Sequence DOJump(this Rigidbody2D target, Vector2 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
        {
            if (numJumps < 1) numJumps = 1;
            float startPosY = 0;
            float offsetY = -1;
            bool offsetYSet = false;
            Sequence s = DOTween.Sequence();
            Tween yTween = DOTween.To(() => target.position, x => target.position = x, new Vector2(0, jumpPower), duration / (numJumps * 2))
                .SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetRelative()
                .SetLoops(numJumps * 2, LoopType.Yoyo)
                .OnStart(() => startPosY = target.position.y);
            s.Append(DOTween.To(() => target.position, x => target.position = x, new Vector2(endValue.x, 0), duration)
                    .SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)
                ).Join(yTween)
                .SetTarget(target).SetEase(DOTween.defaultEaseType);
            yTween.OnUpdate(() => {
                if (!offsetYSet) {
                    offsetYSet = true;
                    offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                }
                Vector3 pos = target.position;
                pos.y += DOVirtual.EasedValue(0, offsetY, yTween.ElapsedPercentage(), Ease.OutQuad);
                target.MovePosition(pos);
            });
            return s;
        }

        /// <summary>Tweens a Rigidbody2D's position through the given path waypoints, using the chosen path algorithm.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
        /// <para>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</para>
        /// <para>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
        /// If you plan to publish there you should use a regular transform.DOPath.</para></summary>
        /// <param name="path">The waypoints to go through</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="pathType">The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)</param>
        /// <param name="pathMode">The path mode: 3D, side-scroller 2D, top-down 2D</param>
        /// <param name="resolution">The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
        /// Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints</param>
        /// <param name="gizmoColor">The color of the path (shown when gizmos are active in the Play panel and the tween is running)</param>
        public static TweenerCore<Vector3, Path, PathOptions> DOPath(
            this Rigidbody2D target, Vector2[] path, float duration, PathType pathType = PathType.Linear,
            PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null
        )
        {
            if (resolution < 1) resolution = 1;
            int len = path.Length;
            Vector3[] path3D = new Vector3[len];
            for (int i = 0; i < len; ++i) path3D[i] = path[i];
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => target.position, x => target.MovePosition(x), new Path(pathType, path3D, resolution, gizmoColor), duration)
                .SetTarget(target).SetUpdate(UpdateType.Fixed);

            t.plugOptions.isRigidbody2D = true;
            t.plugOptions.mode = pathMode;
            return t;
        }
        /// <summary>Tweens a Rigidbody2D's localPosition through the given path waypoints, using the chosen path algorithm.
        /// Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
        /// <para>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</para>
        /// <para>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
        /// If you plan to publish there you should use a regular transform.DOLocalPath.</para></summary>
        /// <param name="path">The waypoint to go through</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="pathType">The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)</param>
        /// <param name="pathMode">The path mode: 3D, side-scroller 2D, top-down 2D</param>
        /// <param name="resolution">The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
        /// Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints</param>
        /// <param name="gizmoColor">The color of the path (shown when gizmos are active in the Play panel and the tween is running)</param>
        public static TweenerCore<Vector3, Path, PathOptions> DOLocalPath(
            this Rigidbody2D target, Vector2[] path, float duration, PathType pathType = PathType.Linear,
            PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null
        )
        {
            if (resolution < 1) resolution = 1;
            int len = path.Length;
            Vector3[] path3D = new Vector3[len];
            for (int i = 0; i < len; ++i) path3D[i] = path[i];
            Transform trans = target.transform;
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => trans.localPosition, x => target.MovePosition(trans.parent == null ? x : trans.parent.TransformPoint(x)), new Path(pathType, path3D, resolution, gizmoColor), duration)
                .SetTarget(target).SetUpdate(UpdateType.Fixed);

            t.plugOptions.isRigidbody2D = true;
            t.plugOptions.mode = pathMode;
            t.plugOptions.useLocalPosition = true;
            return t;
        }
        // Used by path editor when creating the actual tween, so it can pass a pre-compiled path
        internal static TweenerCore<Vector3, Path, PathOptions> DOPath(
            this Rigidbody2D target, Path path, float duration, PathMode pathMode = PathMode.Full3D
        )
        {
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => target.position, x => target.MovePosition(x), path, duration)
                .SetTarget(target);

            t.plugOptions.isRigidbody2D = true;
            t.plugOptions.mode = pathMode;
            return t;
        }
        internal static TweenerCore<Vector3, Path, PathOptions> DOLocalPath(
            this Rigidbody2D target, Path path, float duration, PathMode pathMode = PathMode.Full3D
        )
        {
            Transform trans = target.transform;
            TweenerCore<Vector3, Path, PathOptions> t = DOTween.To(PathPlugin.Get(), () => trans.localPosition, x => target.MovePosition(trans.parent == null ? x : trans.parent.TransformPoint(x)), path, duration)
                .SetTarget(target);

            t.plugOptions.isRigidbody2D = true;
            t.plugOptions.mode = pathMode;
            t.plugOptions.useLocalPosition = true;
            return t;
        }

        #endregion

        #endregion

        #endregion
	}
}
#endif




// File: DOTweenModuleSprite.cs
//===========================================
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

#if true // MODULE_MARKER
using System;
using UnityEngine;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;

#pragma warning disable 1591
namespace DG.Tweening
{
	public static class DOTweenModuleSprite
    {
        #region Shortcuts

        #region SpriteRenderer

        /// <summary>Tweens a SpriteRenderer's color to the given value.
        /// Also stores the spriteRenderer as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOColor(this SpriteRenderer target, Color endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Material's alpha color to the given value.
        /// Also stores the spriteRenderer as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOFade(this SpriteRenderer target, float endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a SpriteRenderer's color using the given gradient
        /// (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="gradient">The gradient to use</param><param name="duration">The duration of the tween</param>
        public static Sequence DOGradientColor(this SpriteRenderer target, Gradient gradient, float duration)
        {
            Sequence s = DOTween.Sequence();
            GradientColorKey[] colors = gradient.colorKeys;
            int len = colors.Length;
            for (int i = 0; i < len; ++i) {
                GradientColorKey c = colors[i];
                if (i == 0 && c.time <= 0) {
                    target.color = c.color;
                    continue;
                }
                float colorDuration = i == len - 1
                    ? duration - s.Duration(false) // Verifies that total duration is correct
                    : duration * (i == 0 ? c.time : c.time - colors[i - 1].time);
                s.Append(target.DOColor(c.color, colorDuration).SetEase(Ease.Linear));
            }
            s.SetTarget(target);
            return s;
        }

        #endregion

        #region Blendables

        #region SpriteRenderer

        /// <summary>Tweens a SpriteRenderer's color to the given value,
        /// in a way that allows other DOBlendableColor tweens to work together on the same target,
        /// instead than fight each other as multiple DOColor would do.
        /// Also stores the SpriteRenderer as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The value to tween to</param><param name="duration">The duration of the tween</param>
        public static Tweener DOBlendableColor(this SpriteRenderer target, Color endValue, float duration)
        {
            endValue = endValue - target.color;
            Color to = new Color(0, 0, 0, 0);
            return DOTween.To(() => to, x => {
                    Color diff = x - to;
                    to = x;
                    target.color += diff;
                }, endValue, duration)
                .Blendable().SetTarget(target);
        }

        #endregion

        #endregion

        #endregion
	}
}
#endif




// File: DOTweenModuleUI.cs
//===========================================
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

#if true // MODULE_MARKER

using System;
using System.Globalization;
using UnityEngine;
using UnityEngine.UI;
using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins;
using DG.Tweening.Plugins.Options;
using Outline = UnityEngine.UI.Outline;
using Text = UnityEngine.UI.Text;

#pragma warning disable 1591
namespace DG.Tweening
{
	public static class DOTweenModuleUI
    {
        #region Shortcuts

        #region CanvasGroup

        /// <summary>Tweens a CanvasGroup's alpha color to the given value.
        /// Also stores the canvasGroup as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<float, float, FloatOptions> DOFade(this CanvasGroup target, float endValue, float duration)
        {
            TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.alpha, x => target.alpha = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #endregion

        #region Graphic

        /// <summary>Tweens an Graphic's color to the given value.
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOColor(this Graphic target, Color endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens an Graphic's alpha color to the given value.
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOFade(this Graphic target, float endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #endregion

        #region Image

        /// <summary>Tweens an Image's color to the given value.
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOColor(this Image target, Color endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens an Image's alpha color to the given value.
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOFade(this Image target, float endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens an Image's fillAmount to the given value.
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach (0 to 1)</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<float, float, FloatOptions> DOFillAmount(this Image target, float endValue, float duration)
        {
            if (endValue > 1) endValue = 1;
            else if (endValue < 0) endValue = 0;
            TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.fillAmount, x => target.fillAmount = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens an Image's colors using the given gradient
        /// (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="gradient">The gradient to use</param><param name="duration">The duration of the tween</param>
        public static Sequence DOGradientColor(this Image target, Gradient gradient, float duration)
        {
            Sequence s = DOTween.Sequence();
            GradientColorKey[] colors = gradient.colorKeys;
            int len = colors.Length;
            for (int i = 0; i < len; ++i) {
                GradientColorKey c = colors[i];
                if (i == 0 && c.time <= 0) {
                    target.color = c.color;
                    continue;
                }
                float colorDuration = i == len - 1
                    ? duration - s.Duration(false) // Verifies that total duration is correct
                    : duration * (i == 0 ? c.time : c.time - colors[i - 1].time);
                s.Append(target.DOColor(c.color, colorDuration).SetEase(Ease.Linear));
            }
            s.SetTarget(target);
            return s;
        }

        #endregion

        #region LayoutElement

        /// <summary>Tweens an LayoutElement's flexibleWidth/Height to the given value.
        /// Also stores the LayoutElement as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOFlexibleSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => new Vector2(target.flexibleWidth, target.flexibleHeight), x => {
                    target.flexibleWidth = x.x;
                    target.flexibleHeight = x.y;
                }, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens an LayoutElement's minWidth/Height to the given value.
        /// Also stores the LayoutElement as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOMinSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => new Vector2(target.minWidth, target.minHeight), x => {
                target.minWidth = x.x;
                target.minHeight = x.y;
            }, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens an LayoutElement's preferredWidth/Height to the given value.
        /// Also stores the LayoutElement as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOPreferredSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => new Vector2(target.preferredWidth, target.preferredHeight), x => {
                target.preferredWidth = x.x;
                target.preferredHeight = x.y;
            }, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        #endregion

        #region Outline

        /// <summary>Tweens a Outline's effectColor to the given value.
        /// Also stores the Outline as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOColor(this Outline target, Color endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.effectColor, x => target.effectColor = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Outline's effectColor alpha to the given value.
        /// Also stores the Outline as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOFade(this Outline target, float endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.effectColor, x => target.effectColor = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Outline's effectDistance to the given value.
        /// Also stores the Outline as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOScale(this Outline target, Vector2 endValue, float duration)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.effectDistance, x => target.effectDistance = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #endregion

        #region RectTransform

        /// <summary>Tweens a RectTransform's anchoredPosition to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPos(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's anchoredPosition X to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPosX(this RectTransform target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(endValue, 0), duration);
            t.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's anchoredPosition Y to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPosY(this RectTransform target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(0, endValue), duration);
            t.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a RectTransform's anchoredPosition3D to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3D(this RectTransform target, Vector3 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's anchoredPosition3D X to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DX(this RectTransform target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, new Vector3(endValue, 0, 0), duration);
            t.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's anchoredPosition3D Y to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DY(this RectTransform target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, new Vector3(0, endValue, 0), duration);
            t.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's anchoredPosition3D Z to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DZ(this RectTransform target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector3, Vector3, VectorOptions> t = DOTween.To(() => target.anchoredPosition3D, x => target.anchoredPosition3D = x, new Vector3(0, 0, endValue), duration);
            t.SetOptions(AxisConstraint.Z, snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a RectTransform's anchorMax to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorMax(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchorMax, x => target.anchorMax = x, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a RectTransform's anchorMin to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorMin(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.anchorMin, x => target.anchorMin = x, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a RectTransform's pivot to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivot(this RectTransform target, Vector2 endValue, float duration)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.pivot, x => target.pivot = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's pivot X to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivotX(this RectTransform target, float endValue, float duration)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.pivot, x => target.pivot = x, new Vector2(endValue, 0), duration);
            t.SetOptions(AxisConstraint.X).SetTarget(target);
            return t;
        }
        /// <summary>Tweens a RectTransform's pivot Y to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivotY(this RectTransform target, float endValue, float duration)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.pivot, x => target.pivot = x, new Vector2(0, endValue), duration);
            t.SetOptions(AxisConstraint.Y).SetTarget(target);
            return t;
        }

        /// <summary>Tweens a RectTransform's sizeDelta to the given value.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOSizeDelta(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
        {
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.sizeDelta, x => target.sizeDelta = x, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        /// <summary>Punches a RectTransform's anchoredPosition towards the given direction and then back to the starting one
        /// as if it was connected to the starting position via an elastic.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="punch">The direction and strength of the punch (added to the RectTransform's current position)</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="vibrato">Indicates how much will the punch vibrate</param>
        /// <param name="elasticity">Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
        /// 1 creates a full oscillation between the punch direction and the opposite direction,
        /// while 0 oscillates only between the punch and the start position</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Tweener DOPunchAnchorPos(this RectTransform target, Vector2 punch, float duration, int vibrato = 10, float elasticity = 1, bool snapping = false)
        {
            return DOTween.Punch(() => target.anchoredPosition, x => target.anchoredPosition = x, punch, duration, vibrato, elasticity)
                .SetTarget(target).SetOptions(snapping);
        }

        /// <summary>Shakes a RectTransform's anchoredPosition with the given values.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="strength">The shake strength</param>
        /// <param name="vibrato">Indicates how much will the shake vibrate</param>
        /// <param name="randomness">Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
        /// Setting it to 0 will shake along a single direction.</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        /// <param name="fadeOut">If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not</param>
        /// <param name="randomnessMode">Randomness mode</param>
        public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, float strength = 100, int vibrato = 10, float randomness = 90, bool snapping = false, bool fadeOut = true, ShakeRandomnessMode randomnessMode = ShakeRandomnessMode.Full)
        {
            return DOTween.Shake(() => target.anchoredPosition, x => target.anchoredPosition = x, duration, strength, vibrato, randomness, true, fadeOut, randomnessMode)
                .SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake).SetOptions(snapping);
        }
        /// <summary>Shakes a RectTransform's anchoredPosition with the given values.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="strength">The shake strength on each axis</param>
        /// <param name="vibrato">Indicates how much will the shake vibrate</param>
        /// <param name="randomness">Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
        /// Setting it to 0 will shake along a single direction.</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        /// <param name="fadeOut">If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not</param>
        /// <param name="randomnessMode">Randomness mode</param>
        public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, Vector2 strength, int vibrato = 10, float randomness = 90, bool snapping = false, bool fadeOut = true, ShakeRandomnessMode randomnessMode = ShakeRandomnessMode.Full)
        {
            return DOTween.Shake(() => target.anchoredPosition, x => target.anchoredPosition = x, duration, strength, vibrato, randomness, fadeOut, randomnessMode)
                .SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake).SetOptions(snapping);
        }

        #region Special

        /// <summary>Tweens a RectTransform's anchoredPosition to the given value, while also applying a jump effect along the Y axis.
        /// Returns a Sequence instead of a Tweener.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param>
        /// <param name="jumpPower">Power of the jump (the max height of the jump is represented by this plus the final Y offset)</param>
        /// <param name="numJumps">Total number of jumps</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Sequence DOJumpAnchorPos(this RectTransform target, Vector2 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
        {
            if (numJumps < 1) numJumps = 1;
            float startPosY = 0;
            float offsetY = -1;
            bool offsetYSet = false;

            // Separate Y Tween so we can elaborate elapsedPercentage on that insted of on the Sequence
            // (in case users add a delay or other elements to the Sequence)
            Sequence s = DOTween.Sequence();
            Tween yTween = DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(0, jumpPower), duration / (numJumps * 2))
                .SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetRelative()
                .SetLoops(numJumps * 2, LoopType.Yoyo)
                .OnStart(()=> startPosY = target.anchoredPosition.y);
            s.Append(DOTween.To(() => target.anchoredPosition, x => target.anchoredPosition = x, new Vector2(endValue.x, 0), duration)
                    .SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)
                ).Join(yTween)
                .SetTarget(target).SetEase(DOTween.defaultEaseType);
            s.OnUpdate(() => {
                if (!offsetYSet) {
                    offsetYSet = true;
                    offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                }
                Vector2 pos = target.anchoredPosition;
                pos.y += DOVirtual.EasedValue(0, offsetY, s.ElapsedDirectionalPercentage(), Ease.OutQuad);
                target.anchoredPosition = pos;
            });
            return s;
        }

        #endregion

        #endregion

        #region ScrollRect

        /// <summary>Tweens a ScrollRect's horizontal/verticalNormalizedPosition to the given value.
        /// Also stores the ScrollRect as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Tweener DONormalizedPos(this ScrollRect target, Vector2 endValue, float duration, bool snapping = false)
        {
            return DOTween.To(() => new Vector2(target.horizontalNormalizedPosition, target.verticalNormalizedPosition),
                x => {
                    target.horizontalNormalizedPosition = x.x;
                    target.verticalNormalizedPosition = x.y;
                }, endValue, duration)
                .SetOptions(snapping).SetTarget(target);
        }
        /// <summary>Tweens a ScrollRect's horizontalNormalizedPosition to the given value.
        /// Also stores the ScrollRect as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Tweener DOHorizontalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
        {
            return DOTween.To(() => target.horizontalNormalizedPosition, x => target.horizontalNormalizedPosition = x, endValue, duration)
                .SetOptions(snapping).SetTarget(target);
        }
        /// <summary>Tweens a ScrollRect's verticalNormalizedPosition to the given value.
        /// Also stores the ScrollRect as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static Tweener DOVerticalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
        {
            return DOTween.To(() => target.verticalNormalizedPosition, x => target.verticalNormalizedPosition = x, endValue, duration)
                .SetOptions(snapping).SetTarget(target);
        }

        #endregion

        #region Slider

        /// <summary>Tweens a Slider's value to the given value.
        /// Also stores the Slider as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<float, float, FloatOptions> DOValue(this Slider target, float endValue, float duration, bool snapping = false)
        {
            TweenerCore<float, float, FloatOptions> t = DOTween.To(() => target.value, x => target.value = x, endValue, duration);
            t.SetOptions(snapping).SetTarget(target);
            return t;
        }

        #endregion

        #region Text

        /// <summary>Tweens a Text's color to the given value.
        /// Also stores the Text as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOColor(this Text target, Color endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.To(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>
        /// Tweens a Text's text from one integer to another, with options for thousands separators
        /// </summary>
        /// <param name="fromValue">The value to start from</param>
        /// <param name="endValue">The end value to reach</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="addThousandsSeparator">If TRUE (default) also adds thousands separators</param>
        /// <param name="culture">The <see cref="CultureInfo"/> to use (InvariantCulture if NULL)</param>
        public static TweenerCore<int, int, NoOptions> DOCounter(
            this Text target, int fromValue, int endValue, float duration, bool addThousandsSeparator = true, CultureInfo culture = null
        ){
            int v = fromValue;
            CultureInfo cInfo = !addThousandsSeparator ? null : culture ?? CultureInfo.InvariantCulture;
            TweenerCore<int, int, NoOptions> t = DOTween.To(() => v, x => {
                v = x;
                target.text = addThousandsSeparator
                    ? v.ToString("N0", cInfo)
                    : v.ToString();
            }, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Text's alpha color to the given value.
        /// Also stores the Text as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param><param name="duration">The duration of the tween</param>
        public static TweenerCore<Color, Color, ColorOptions> DOFade(this Text target, float endValue, float duration)
        {
            TweenerCore<Color, Color, ColorOptions> t = DOTween.ToAlpha(() => target.color, x => target.color = x, endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Text's text to the given value.
        /// Also stores the Text as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end string to tween to</param><param name="duration">The duration of the tween</param>
        /// <param name="richTextEnabled">If TRUE (default), rich text will be interpreted correctly while animated,
        /// otherwise all tags will be considered as normal text</param>
        /// <param name="scrambleMode">The type of scramble mode to use, if any</param>
        /// <param name="scrambleChars">A string containing the characters to use for scrambling.
        /// Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better results with more characters.
        /// Leave it to NULL (default) to use default ones</param>
        public static TweenerCore<string, string, StringOptions> DOText(this Text target, string endValue, float duration, bool richTextEnabled = true, ScrambleMode scrambleMode = ScrambleMode.None, string scrambleChars = null)
        {
            if (endValue == null) {
                if (Debugger.logPriority > 0) Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
                endValue = "";
            }
            TweenerCore<string, string, StringOptions> t = DOTween.To(() => target.text, x => target.text = x, endValue, duration);
            t.SetOptions(richTextEnabled, scrambleMode, scrambleChars)
                .SetTarget(target);
            return t;
        }

        #endregion

        #region Blendables

        #region Graphic

        /// <summary>Tweens a Graphic's color to the given value,
        /// in a way that allows other DOBlendableColor tweens to work together on the same target,
        /// instead than fight each other as multiple DOColor would do.
        /// Also stores the Graphic as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The value to tween to</param><param name="duration">The duration of the tween</param>
        public static Tweener DOBlendableColor(this Graphic target, Color endValue, float duration)
        {
            endValue = endValue - target.color;
            Color to = new Color(0, 0, 0, 0);
            return DOTween.To(() => to, x => {
                Color diff = x - to;
                to = x;
                target.color += diff;
            }, endValue, duration)
                .Blendable().SetTarget(target);
        }

        #endregion

        #region Image

        /// <summary>Tweens a Image's color to the given value,
        /// in a way that allows other DOBlendableColor tweens to work together on the same target,
        /// instead than fight each other as multiple DOColor would do.
        /// Also stores the Image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The value to tween to</param><param name="duration">The duration of the tween</param>
        public static Tweener DOBlendableColor(this Image target, Color endValue, float duration)
        {
            endValue = endValue - target.color;
            Color to = new Color(0, 0, 0, 0);
            return DOTween.To(() => to, x => {
                Color diff = x - to;
                to = x;
                target.color += diff;
            }, endValue, duration)
                .Blendable().SetTarget(target);
        }

        #endregion

        #region Text

        /// <summary>Tweens a Text's color BY the given value,
        /// in a way that allows other DOBlendableColor tweens to work together on the same target,
        /// instead than fight each other as multiple DOColor would do.
        /// Also stores the Text as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The value to tween to</param><param name="duration">The duration of the tween</param>
        public static Tweener DOBlendableColor(this Text target, Color endValue, float duration)
        {
            endValue = endValue - target.color;
            Color to = new Color(0, 0, 0, 0);
            return DOTween.To(() => to, x => {
                Color diff = x - to;
                to = x;
                target.color += diff;
            }, endValue, duration)
                .Blendable().SetTarget(target);
        }

        #endregion

        #endregion

        #region Shapes

        /// <summary>Tweens a RectTransform's anchoredPosition so that it draws a circle around the given center.
        /// Also stores the RectTransform as the tween's target so it can be used for filtered operations.<para/>
        /// IMPORTANT: SetFrom(value) requires a <see cref="Vector2"/> instead of a float, where the X property represents the "from degrees value"</summary>
        /// <param name="center">Circle-center/pivot around which to rotate (in UI anchoredPosition coordinates)</param>
        /// <param name="endValueDegrees">The end value degrees to reach (to rotate counter-clockwise pass a negative value)</param>
        /// <param name="duration">The duration of the tween</param>
        /// <param name="relativeCenter">If TRUE the <see cref="center"/> coordinates will be considered as relative to the target's current anchoredPosition</param>
        /// <param name="snapping">If TRUE the tween will smoothly snap all values to integers</param>
        public static TweenerCore<Vector2, Vector2, CircleOptions> DOShapeCircle(
            this RectTransform target, Vector2 center, float endValueDegrees, float duration, bool relativeCenter = false, bool snapping = false
        )
        {
            TweenerCore<Vector2, Vector2, CircleOptions> t = DOTween.To(
                CirclePlugin.Get(), () => target.anchoredPosition, x => target.anchoredPosition = x, center, duration
            );
            t.SetOptions(endValueDegrees, relativeCenter, snapping).SetTarget(target);
            return t;
        }

        #endregion

        #endregion

        // ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
        // ‚ñà‚ñà‚ñà INTERNAL CLASSES ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
        // ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

        public static class Utils
        {
            /// <summary>
            /// Converts the anchoredPosition of the first RectTransform to the second RectTransform,
            /// taking into consideration offset, anchors and pivot, and returns the new anchoredPosition
            /// </summary>
            public static Vector2 SwitchToRectTransform(RectTransform from, RectTransform to)
            {
                Vector2 localPoint;
                Vector2 fromPivotDerivedOffset = new Vector2(from.rect.width * 0.5f + from.rect.xMin, from.rect.height * 0.5f + from.rect.yMin);
                Vector2 screenP = RectTransformUtility.WorldToScreenPoint(null, from.position);
                screenP += fromPivotDerivedOffset;
                RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, out localPoint);
                Vector2 pivotDerivedOffset = new Vector2(to.rect.width * 0.5f + to.rect.xMin, to.rect.height * 0.5f + to.rect.yMin);
                return to.anchoredPosition + localPoint - pivotDerivedOffset;
            }
        }
	}
}
#endif




// File: DOTweenModuleUnityVersion.cs
//===========================================
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

using System;
using UnityEngine;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
//#if UNITY_2018_1_OR_NEWER && (NET_4_6 || NET_STANDARD_2_0)
//using Task = System.Threading.Tasks.Task;
//#endif

#pragma warning disable 1591
namespace DG.Tweening
{
    /// <summary>
    /// Shortcuts/functions that are not strictly related to specific Modules
    /// but are available only on some Unity versions
    /// </summary>
	public static class DOTweenModuleUnityVersion
    {
        #region Material

        /// <summary>Tweens a Material's color using the given gradient
        /// (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="gradient">The gradient to use</param><param name="duration">The duration of the tween</param>
        public static Sequence DOGradientColor(this Material target, Gradient gradient, float duration)
        {
            Sequence s = DOTween.Sequence();
            GradientColorKey[] colors = gradient.colorKeys;
            int len = colors.Length;
            for (int i = 0; i < len; ++i) {
                GradientColorKey c = colors[i];
                if (i == 0 && c.time <= 0) {
                    target.color = c.color;
                    continue;
                }
                float colorDuration = i == len - 1
                    ? duration - s.Duration(false) // Verifies that total duration is correct
                    : duration * (i == 0 ? c.time : c.time - colors[i - 1].time);
                s.Append(target.DOColor(c.color, colorDuration).SetEase(Ease.Linear));
            }
            s.SetTarget(target);
            return s;
        }
        /// <summary>Tweens a Material's named color property using the given gradient
        /// (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
        /// Also stores the image as the tween's target so it can be used for filtered operations</summary>
        /// <param name="gradient">The gradient to use</param>
        /// <param name="property">The name of the material property to tween (like _Tint or _SpecColor)</param>
        /// <param name="duration">The duration of the tween</param>
        public static Sequence DOGradientColor(this Material target, Gradient gradient, string property, float duration)
        {
            Sequence s = DOTween.Sequence();
            GradientColorKey[] colors = gradient.colorKeys;
            int len = colors.Length;
            for (int i = 0; i < len; ++i) {
                GradientColorKey c = colors[i];
                if (i == 0 && c.time <= 0) {
                    target.SetColor(property, c.color);
                    continue;
                }
                float colorDuration = i == len - 1
                    ? duration - s.Duration(false) // Verifies that total duration is correct
                    : duration * (i == 0 ? c.time : c.time - colors[i - 1].time);
                s.Append(target.DOColor(c.color, property, colorDuration).SetEase(Ease.Linear));
            }
            s.SetTarget(target);
            return s;
        }

        #endregion

        #region CustomYieldInstructions

        /// <summary>
        /// Returns a <see cref="CustomYieldInstruction"/> that waits until the tween is killed or complete.
        /// It can be used inside a coroutine as a yield.
        /// <para>Example usage:</para><code>yield return myTween.WaitForCompletion(true);</code>
        /// </summary>
        public static CustomYieldInstruction WaitForCompletion(this Tween t, bool returnCustomYieldInstruction)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return null;
            }
            return new DOTweenCYInstruction.WaitForCompletion(t);
        }

        /// <summary>
        /// Returns a <see cref="CustomYieldInstruction"/> that waits until the tween is killed or rewinded.
        /// It can be used inside a coroutine as a yield.
        /// <para>Example usage:</para><code>yield return myTween.WaitForRewind();</code>
        /// </summary>
        public static CustomYieldInstruction WaitForRewind(this Tween t, bool returnCustomYieldInstruction)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return null;
            }
            return new DOTweenCYInstruction.WaitForRewind(t);
        }

        /// <summary>
        /// Returns a <see cref="CustomYieldInstruction"/> that waits until the tween is killed.
        /// It can be used inside a coroutine as a yield.
        /// <para>Example usage:</para><code>yield return myTween.WaitForKill();</code>
        /// </summary>
        public static CustomYieldInstruction WaitForKill(this Tween t, bool returnCustomYieldInstruction)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return null;
            }
            return new DOTweenCYInstruction.WaitForKill(t);
        }

        /// <summary>
        /// Returns a <see cref="CustomYieldInstruction"/> that waits until the tween is killed or has gone through the given amount of loops.
        /// It can be used inside a coroutine as a yield.
        /// <para>Example usage:</para><code>yield return myTween.WaitForElapsedLoops(2);</code>
        /// </summary>
        /// <param name="elapsedLoops">Elapsed loops to wait for</param>
        public static CustomYieldInstruction WaitForElapsedLoops(this Tween t, int elapsedLoops, bool returnCustomYieldInstruction)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return null;
            }
            return new DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
        }

        /// <summary>
        /// Returns a <see cref="CustomYieldInstruction"/> that waits until the tween is killed
        /// or has reached the given time position (loops included, delays excluded).
        /// It can be used inside a coroutine as a yield.
        /// <para>Example usage:</para><code>yield return myTween.WaitForPosition(2.5f);</code>
        /// </summary>
        /// <param name="position">Position (loops included, delays excluded) to wait for</param>
        public static CustomYieldInstruction WaitForPosition(this Tween t, float position, bool returnCustomYieldInstruction)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return null;
            }
            return new DOTweenCYInstruction.WaitForPosition(t, position);
        }

        /// <summary>
        /// Returns a <see cref="CustomYieldInstruction"/> that waits until the tween is killed or started
        /// (meaning when the tween is set in a playing state the first time, after any eventual delay).
        /// It can be used inside a coroutine as a yield.
        /// <para>Example usage:</para><code>yield return myTween.WaitForStart();</code>
        /// </summary>
        public static CustomYieldInstruction WaitForStart(this Tween t, bool returnCustomYieldInstruction)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return null;
            }
            return new DOTweenCYInstruction.WaitForStart(t);
        }

        #endregion

#if UNITY_2018_1_OR_NEWER
        #region Unity 2018.1 or Newer

        #region Material

        /// <summary>Tweens a Material's named texture offset property with the given ID to the given value.
        /// Also stores the material as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param>
        /// <param name="propertyID">The ID of the material property to tween (also called nameID in Unity's manual)</param>
        /// <param name="duration">The duration of the tween</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOOffset(this Material target, Vector2 endValue, int propertyID, float duration)
        {
            if (!target.HasProperty(propertyID)) {
                if (Debugger.logPriority > 0) Debugger.LogMissingMaterialProperty(propertyID);
                return null;
            }
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.GetTextureOffset(propertyID), x => target.SetTextureOffset(propertyID, x), endValue, duration);
            t.SetTarget(target);
            return t;
        }

        /// <summary>Tweens a Material's named texture scale property with the given ID to the given value.
        /// Also stores the material as the tween's target so it can be used for filtered operations</summary>
        /// <param name="endValue">The end value to reach</param>
        /// <param name="propertyID">The ID of the material property to tween (also called nameID in Unity's manual)</param>
        /// <param name="duration">The duration of the tween</param>
        public static TweenerCore<Vector2, Vector2, VectorOptions> DOTiling(this Material target, Vector2 endValue, int propertyID, float duration)
        {
            if (!target.HasProperty(propertyID)) {
                if (Debugger.logPriority > 0) Debugger.LogMissingMaterialProperty(propertyID);
                return null;
            }
            TweenerCore<Vector2, Vector2, VectorOptions> t = DOTween.To(() => target.GetTextureScale(propertyID), x => target.SetTextureScale(propertyID, x), endValue, duration);
            t.SetTarget(target);
            return t;
        }

        #endregion

        #region .NET 4.6 or Newer

#if UNITY_2018_1_OR_NEWER && (NET_4_6 || NET_STANDARD_2_0)

        #region Async Instructions

        /// <summary>
        /// Returns an async <see cref="System.Threading.Tasks.Task"/> that waits until the tween is killed or complete.
        /// It can be used inside an async operation.
        /// <para>Example usage:</para><code>await myTween.WaitForCompletion();</code>
        /// </summary>
        public static async System.Threading.Tasks.Task AsyncWaitForCompletion(this Tween t)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return;
            }
            while (t.active && !t.IsComplete()) await System.Threading.Tasks.Task.Yield();
        }

        /// <summary>
        /// Returns an async <see cref="System.Threading.Tasks.Task"/> that waits until the tween is killed or rewinded.
        /// It can be used inside an async operation.
        /// <para>Example usage:</para><code>await myTween.AsyncWaitForRewind();</code>
        /// </summary>
        public static async System.Threading.Tasks.Task AsyncWaitForRewind(this Tween t)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return;
            }
            while (t.active && (!t.playedOnce || t.position * (t.CompletedLoops() + 1) > 0)) await System.Threading.Tasks.Task.Yield();
        }

        /// <summary>
        /// Returns an async <see cref="System.Threading.Tasks.Task"/> that waits until the tween is killed.
        /// It can be used inside an async operation.
        /// <para>Example usage:</para><code>await myTween.AsyncWaitForKill();</code>
        /// </summary>
        public static async System.Threading.Tasks.Task AsyncWaitForKill(this Tween t)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return;
            }
            while (t.active) await System.Threading.Tasks.Task.Yield();
        }

        /// <summary>
        /// Returns an async <see cref="System.Threading.Tasks.Task"/> that waits until the tween is killed or has gone through the given amount of loops.
        /// It can be used inside an async operation.
        /// <para>Example usage:</para><code>await myTween.AsyncWaitForElapsedLoops();</code>
        /// </summary>
        /// <param name="elapsedLoops">Elapsed loops to wait for</param>
        public static async System.Threading.Tasks.Task AsyncWaitForElapsedLoops(this Tween t, int elapsedLoops)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return;
            }
            while (t.active && t.CompletedLoops() < elapsedLoops) await System.Threading.Tasks.Task.Yield();
        }

        /// <summary>
        /// Returns an async <see cref="System.Threading.Tasks.Task"/> that waits until the tween is killed or started
        /// (meaning when the tween is set in a playing state the first time, after any eventual delay).
        /// It can be used inside an async operation.
        /// <para>Example usage:</para><code>await myTween.AsyncWaitForPosition();</code>
        /// </summary>
        /// <param name="position">Position (loops included, delays excluded) to wait for</param>
        public static async System.Threading.Tasks.Task AsyncWaitForPosition(this Tween t, float position)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return;
            }
            while (t.active && t.position * (t.CompletedLoops() + 1) < position) await System.Threading.Tasks.Task.Yield();
        }

        /// <summary>
        /// Returns an async <see cref="System.Threading.Tasks.Task"/> that waits until the tween is killed.
        /// It can be used inside an async operation.
        /// <para>Example usage:</para><code>await myTween.AsyncWaitForKill();</code>
        /// </summary>
        public static async System.Threading.Tasks.Task AsyncWaitForStart(this Tween t)
        {
            if (!t.active) {
                if (Debugger.logPriority > 0) Debugger.LogInvalidTween(t);
                return;
            }
            while (t.active && !t.playedOnce) await System.Threading.Tasks.Task.Yield();
        }

        #endregion
#endif

        #endregion

        #endregion
#endif
    }

    // ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
    // ‚ñà‚ñà‚ñà CLASSES ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
    // ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

    public static class DOTweenCYInstruction
    {
        public class WaitForCompletion : CustomYieldInstruction
        {
            public override bool keepWaiting { get {
                return t.active && !t.IsComplete();
            }}
            readonly Tween t;
            public WaitForCompletion(Tween tween)
            {
                t = tween;
            }
        }

        public class WaitForRewind : CustomYieldInstruction
        {
            public override bool keepWaiting { get {
                return t.active && (!t.playedOnce || t.position * (t.CompletedLoops() + 1) > 0);
            }}
            readonly Tween t;
            public WaitForRewind(Tween tween)
            {
                t = tween;
            }
        }

        public class WaitForKill : CustomYieldInstruction
        {
            public override bool keepWaiting { get {
                return t.active;
            }}
            readonly Tween t;
            public WaitForKill(Tween tween)
            {
                t = tween;
            }
        }

        public class WaitForElapsedLoops : CustomYieldInstruction
        {
            public override bool keepWaiting { get {
                return t.active && t.CompletedLoops() < elapsedLoops;
            }}
            readonly Tween t;
            readonly int elapsedLoops;
            public WaitForElapsedLoops(Tween tween, int elapsedLoops)
            {
                t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }

        public class WaitForPosition : CustomYieldInstruction
        {
            public override bool keepWaiting { get {
                return t.active && t.position * (t.CompletedLoops() + 1) < position;
            }}
            readonly Tween t;
            readonly float position;
            public WaitForPosition(Tween tween, float position)
            {
                t = tween;
                this.position = position;
            }
        }

        public class WaitForStart : CustomYieldInstruction
        {
            public override bool keepWaiting { get {
                return t.active && !t.playedOnce;
            }}
            readonly Tween t;
            public WaitForStart(Tween tween)
            {
                t = tween;
            }
        }
    }
}




// File: DOTweenModuleUtils.cs
//===========================================
// Author: Daniele Giardini - http://www.demigiant.com
// Created: 2018/07/13

using System;
using System.Reflection;
using UnityEngine;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;

#pragma warning disable 1591
namespace DG.Tweening
{
    /// <summary>
    /// Utility functions that deal with available Modules.
    /// Modules defines:
    /// - DOTAUDIO
    /// - DOTPHYSICS
    /// - DOTPHYSICS2D
    /// - DOTSPRITE
    /// - DOTUI
    /// Extra defines set and used for implementation of external assets:
    /// - DOTWEEN_TMP ‚ñ∫ TextMesh Pro
    /// - DOTWEEN_TK2D ‚ñ∫ 2D Toolkit
    /// </summary>
	public static class DOTweenModuleUtils
    {
        static bool _initialized;

        #region Reflection

        /// <summary>
        /// Called via Reflection by DOTweenComponent on Awake
        /// </summary>
#if UNITY_2018_1_OR_NEWER
        [UnityEngine.Scripting.Preserve]
#endif
        public static void Init()
        {
            if (_initialized) return;

            _initialized = true;
            DOTweenExternalCommand.SetOrientationOnPath += Physics.SetOrientationOnPath;

#if UNITY_EDITOR
#if UNITY_4_3 || UNITY_4_4 || UNITY_4_5 || UNITY_4_6 || UNITY_5 || UNITY_2017_1
            UnityEditor.EditorApplication.playmodeStateChanged += PlaymodeStateChanged;
#else
            UnityEditor.EditorApplication.playModeStateChanged += PlaymodeStateChanged;
#endif
#endif
        }

#if UNITY_2018_1_OR_NEWER
#pragma warning disable
        [UnityEngine.Scripting.Preserve]
        // Just used to preserve methods when building, never called
        static void Preserver()
        {
            Assembly[] loadedAssemblies = AppDomain.CurrentDomain.GetAssemblies();
            MethodInfo mi = typeof(MonoBehaviour).GetMethod("Stub");
        }
#pragma warning restore
#endif

        #endregion

#if UNITY_EDITOR
        // Fires OnApplicationPause in DOTweenComponent even when Editor is paused (otherwise it's only fired at runtime)
#if UNITY_4_3 || UNITY_4_4 || UNITY_4_5 || UNITY_4_6 || UNITY_5 || UNITY_2017_1
        static void PlaymodeStateChanged()
        #else
        static void PlaymodeStateChanged(UnityEditor.PlayModeStateChange state)
#endif
        {
            if (DOTween.instance == null) return;
            DOTween.instance.OnApplicationPause(UnityEditor.EditorApplication.isPaused);
        }
#endif

        // ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
        // ‚ñà‚ñà‚ñà INTERNAL CLASSES ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
        // ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà

        public static class Physics
        {
            // Called via DOTweenExternalCommand callback
            public static void SetOrientationOnPath(PathOptions options, Tween t, Quaternion newRot, Transform trans)
            {
#if true // PHYSICS_MARKER
                if (options.isRigidbody) ((Rigidbody)t.target).rotation = newRot;
                else trans.rotation = newRot;
#else
                trans.rotation = newRot;
#endif
            }

            // Returns FALSE if the DOTween's Physics2D Module is disabled, or if there's no Rigidbody2D attached
            public static bool HasRigidbody2D(Component target)
            {
#if true // PHYSICS2D_MARKER
                return target.GetComponent<Rigidbody2D>() != null;
#else
                return false;
#endif
            }

            #region Called via Reflection


            // Called via Reflection by DOTweenPathInspector
            // Returns FALSE if the DOTween's Physics Module is disabled, or if there's no rigidbody attached
#if UNITY_2018_1_OR_NEWER
            [UnityEngine.Scripting.Preserve]
#endif
            public static bool HasRigidbody(Component target)
            {
#if true // PHYSICS_MARKER
                return target.GetComponent<Rigidbody>() != null;
#else
                return false;
#endif
            }

            // Called via Reflection by DOTweenPath
#if UNITY_2018_1_OR_NEWER
            [UnityEngine.Scripting.Preserve]
#endif
            public static TweenerCore<Vector3, Path, PathOptions> CreateDOTweenPathTween(
                MonoBehaviour target, bool tweenRigidbody, bool isLocal, Path path, float duration, PathMode pathMode
            ){
                TweenerCore<Vector3, Path, PathOptions> t = null;
                bool rBodyFoundAndTweened = false;
#if true // PHYSICS_MARKER
                if (tweenRigidbody) {
                    Rigidbody rBody = target.GetComponent<Rigidbody>();
                    if (rBody != null) {
                        rBodyFoundAndTweened = true;
                        t = isLocal
                            ? rBody.DOLocalPath(path, duration, pathMode)
                            : rBody.DOPath(path, duration, pathMode);
                    }
                }
#endif
#if true // PHYSICS2D_MARKER
                if (!rBodyFoundAndTweened && tweenRigidbody) {
                    Rigidbody2D rBody2D = target.GetComponent<Rigidbody2D>();
                    if (rBody2D != null) {
                        rBodyFoundAndTweened = true;
                        t = isLocal
                            ? rBody2D.DOLocalPath(path, duration, pathMode)
                            : rBody2D.DOPath(path, duration, pathMode);
                    }
                }
#endif
                if (!rBodyFoundAndTweened) {
                    t = isLocal
                        ? target.transform.DOLocalPath(path, duration, pathMode)
                        : target.transform.DOPath(path, duration, pathMode);
                }
                return t;
            }

            #endregion
        }
    }
}




